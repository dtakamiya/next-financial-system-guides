# 付録B：よくある質問 (FAQ)

### Q1: バリデーションはどこに書くべきですか？

**A1:** バリデーションの種類によって置き場所が異なります。

1.  **構文的なバリデーション (Syntactic Validation)**
    -   **内容**: `null`でないこと、文字列が空でないこと、最大長を超えていないこと、メールアドレスの形式であることなど。
    -   **場所**: **プレゼンテーション層 (Controller)**。`@Valid`アノテーションとBean Validation (`@NotNull`, `@Size`, `@Email`など) を使って、DTOに対して行います。アプリケーションのコアロジックに到達する前に、不正な形式のリクエストを弾くのが目的です。

    ```java
    // DTOでのバリデーション
    public record OpenAccountCommand(
        @NotNull @Size(min = 1, max = 36) String customerId
    ) {}

    // Controllerでのバリデーション
    @PostMapping
    public void openAccount(@RequestBody @Valid OpenAccountCommand command) {
        // ...
    }
    ```

2.  **ビジネスルールとしてのバリデーション (Business Rule Validation)**
    -   **内容**: 「口座の残高はマイナスになれない」「送金先の口座が存在するか」といった、ビジネス上の制約。
    -   **場所**: **ドメイン層 (エンティティ、値オブジェクト)**。
        -   **値オブジェクトのコンストラクタ**: 「金額は正の数でなければならない」といった、そのオブジェクトが単独で成立するための不変条件。
        -   **エンティティのメソッド**: 「残高が不足していれば出金できない」といった、エンティティの状態に依存するビジネスルール。
        -   **アプリケーションサービス**: 「送金元と送金先の口座が同じであってはならない」といった、複数の集約にまたがるビジネスルール。

### Q2: ドメイン層とアプリケーション層の違いがよく分かりません。

**A2:** シンプルに言うと、**「何を(What)」と「どのように(How)」の違い**です。

-   **ドメイン層 (Domain Layer)**: **「何を」** を担当します。
    -   ビジネスのルールそのものを表現します。
    -   「口座(Account)は、入金(deposit)できる」「出金(withdraw)できる」といった、ビジネスの能力とルールを定義します。
    -   ドメイン層は、自分が「誰に」「どのユースケースで」使われるかを知りません。

-   **アプリケーション層 (Application Layer)**: **「どのように」** を担当します。
    -   ドメイン層のオブジェクトを組み合わせて、具体的なユースケース（機能）を実現します。
    -   「ユーザーからリクエストを受け取ったら、`AccountRepository`で`Account`インスタンスを取得し、その`deposit`メソッドを呼び出して、結果を保存する」という一連の**手順（ワークフロー）**を定義します。
    -   トランザクションの管理もこの層の責務です。

### Q3: 複数のマイクロサービスにまたがるデータを参照したい場合はどうすれば良いですか？

**A3:** いくつかのパターンがありますが、**サービス間で直接データベースを共有するのはアンチパターン**です。

1.  **APIによる同期的な取得 (非推奨)**
    -   サービスAがサービスBのAPIを直接呼び出して情報を取得します。
    -   簡単ですが、サービスBが停止しているとサービスAも影響を受ける**可用性の低下**や、レスポンスタイムの悪化に繋がります。限定的な利用に留めるべきです。

2.  **データの複製 (推奨)**
    -   サービスAは、サービスBが公開する**ドメインイベント**（例: `CustomerNameChangedEvent`）を購読します。
    -   イベントを受け取ったら、サービスAは自身のデータベースに必要な情報（この例では顧客名）を保存します。
    -   データは時間差で同期されますが（結果整合性）、サービスBに依存することなく自律的に動作できます。

### Q4: 1つのトランザクションで複数の集約を更新したいです。

**A4:** **原則として、1つのトランザクションで更新する集約は1つだけにすべき**です。複数の集約を1つのトランザクションで更新しようとすると、集約の境界が曖昧になり、複雑性が増大します。

もし複数の集約の更新が必要な場合は、**ドメインイベントと結果整合性 (Eventual Consistency)** のアプローチを検討してください。

**例：口座開設時に、顧客の「開設口座数」も更新したい場合**
1.  **口座サービス**が口座を開設し、トランザクションをコミットします。
2.  成功したら `AccountOpenedEvent` を発行します。
3.  **顧客サービス**が `AccountOpenedEvent` を購読し、それを受けて該当する顧客の「開設口座数」をインクリメントする別のトランザクションを開始します。

この方法なら、口座開設と顧客情報の更新が疎結合になり、それぞれのサービスの責務が明確に保たれます。

### Q5: MyBatisではなくJPA/Hibernateを使ってはいけませんか？

**A5:** もちろん可能です。JPA/Hibernateは、シンプルなCRUD操作では非常に生産性が高いです。

このガイドでMyBatisを推奨する理由は以下の通りです。

-   **SQLのコントロール**: 金融システムでは、パフォーマンスチューニングのために特定のインデックスを使ったり、複雑な結合を行ったりと、SQLを細かく制御したい場面が多々あります。MyBatisはSQLを直接記述できるため、このような要求に柔軟に対応できます。
-   **マッピングの柔軟性**: DDDの豊かなドメインモデル（特に値オブジェクト）と、RDBのテーブル構造との間のマッピング（インピーダンスミスマッチ）を、`TypeHandler`などを使って細かく調整しやすいです。

どちらの技術にも一長一短があるため、プロジェクトの特性に合わせて選択することが重要です。 