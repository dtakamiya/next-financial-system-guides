## 7. よくある質問 (FAQ) とアンチパターン

このセクションでは、DDDでの開発において頻繁に直面する疑問や、陥りがちなアンチパターンについて解説します。

### Q1: バリデーションはどこに書くべき？
**A. 責務に応じて複数のレイヤーに書きます。一つの場所にまとめようとしないことが重要です。**
- **値オブジェクト (ドメイン層)**:
    - **責務**: オブジェクトとして存在するために必須の、不変のルール。
    - **例**: `Money`オブジェクトの金額がマイナスではないこと、通貨コードがISO形式であること。`new Money(new BigDecimal("-100"))` の時点で例外をスローし、不正なオブジェクトの生成を防ぎます。
- **エンティティ / ドメインサービス (ドメイン層)**:
    - **責務**: ビジネスプロセス上のルール。他のエンティティの状態にも依存することがあります。
    - **例**: `Account`エンティティの`withdraw`メソッド内で、残高が不足していないかチェックする。振込処理で、振込元と振込先が同じ口座でないことを確認する。
- **アプリケーションサービス (アプリケーション層)**:
    - **責務**: ユースケースを実行するための事前条件のチェック。
    - **例**: 外部から渡されたIDでリソースが存在するかどうかを確認する。べき等性を担保するために、既に処理済みのリクエストIDでないかチェックする。
- **プレゼンテーション層 (DTO)**:
    - **責務**: 入力値の基本的な形式チェック。
    - **例**: `@NotBlank`や`@Email`などのBean Validationアノテーションを使い、リクエストがアプリケーションサービスに到達する前に基本的な形式エラーを弾く。

### Q2: DTOとドメインオブジェクトの使い分けは？APIでドメインオブジェクトを直接返すべき？
**A. いいえ、ドメインオブジェクトを直接APIのレスポンスとして返すべきではありません。必ずDTO（Data Transfer Object）に変換してください。**

- **なぜ？ (理由)**
    - **関心の分離**: プレゼンテーション層（APIの見た目）の要求と、ドメイン層（ビジネスルール）の要求は異なります。ドメインオブジェクトを直接返すと、UIの都合（「この項目も追加で表示したい」など）でドメインモデルが歪められる危険性があります。
    - **情報の隠蔽**: ドメインオブジェクトには永続化のための`version`情報や、内部的な状態を持つことがあります。これらを外部に公開するのは、カプセル化を破壊し、セキュリティリスクになり得ます。DTOを使うことで、外部に公開する情報を意図的に選択できます。
- **アンチパターン: ドメインモデルの直接公開**
    - `@RestController`から`Account`エンティティを直接返してしまうと、`Account`クラスのフィールド変更が意図せずAPI仕様の変更に繋がってしまいます。
- **ベストプラクティス: DTOへの変換**
    - アプリケーションサービスがリポジトリから取得したドメインオブジェクトを操作し、その結果をプレゼンテーション層に返すDTOにマッピングします。この変換処理はアプリケーションサービスか、専用のMapperクラスが担当します。

### Q3: トランザクション境界はどこに置くべき？
**A. アプリケーションサービスのpublicメソッドに設定するのが基本です。**

- **原則**: 1ユースケース = 1トランザクション。
- **実装**: Springでは、アプリケーションサービスのメソッドに`@Transactional`アノテーションを付与することで、メソッドの開始時にトランザクションが始まり、正常に終了すればコミット、例外が発生すればロールバックされます。
- **アンチパターン**:
    - **Controllerに`@Transactional`を付与する**: レスポンスのレンダリングまでトランザクションが延長され、不必要にDBコネクションを保持してしまいます。
    - **リポジトリメソッドごとにトランザクションをかける**: `a.save(); b.save();` のような処理で、`a`の保存は成功し`b`で失敗した場合に一貫性が崩れます。ユースケース全体を一つのトランザクションで囲むべきです。

### Q4: 貧血ドメインモデルを避けるには？
**A. 「Tell, Don't Ask (尋ねるな、命じろ)」の原則に従い、データとその振る舞いを同じオブジェクト（エンティティ）にまとめます。**

- **貧血ドメインモデルとは？**: getter/setterしか持たない単なるデータコンテナと化したドメインオブジェクトのこと。ビジネスロジックはすべてサービスクラスに実装されてしまいます。これは単なる手続き型プログラミングであり、DDDのメリットを享受できません。
- **アンチパターン: Service層でのロジック実装**
    ```java
    // BAD: Serviceクラスでロジックを実装
    public void withdraw(String accountId, Money amount) {
        Account account = accountRepository.findById(accountId);
        if (account.getBalance().isLessThan(amount)) { // ロジックが外部にある
            throw new Exception();
        }
        account.setBalance(account.getBalance().subtract(amount)); // ただのsetter
        accountRepository.save(account);
    }
    ```
- **ベストプラクティス: エンティティへのロジック移譲**
    ```java
    // GOOD: エンティティ自身が振る舞いを持つ
    // ApplicationService
    public void withdraw(String accountId, Money amount) {
        Account account = accountRepository.findById(accountId);
        account.withdraw(amount); // エンティティに命じる
        accountRepository.save(account);
    }

    // Account (Entity)
    public void withdraw(Money amount) {
        if (this.balance.isLessThan(amount)) { // ロジックは内部にある
            throw new InsufficientFundsException();
        }
        this.balance = this.balance.subtract(amount);
    }
    ```

### Q5: 巨大な集約（God Aggregate）を防ぐには？
**A. トランザクション整合性の境界を正しく見極め、集約を小さく保つことが重要です。**

- **集約の役割**: 一貫性を保つための単位。集約内のオブジェクトは、一つのトランザクションで必ず整合性が取れている状態に保たれます。
- **アンチパターン: 何でもかんでも一つの集約に含める**
    - 例: `顧客`集約に、その顧客の`取引履歴`（数千件になる可能性）のリストをすべて含めてしまう。
    - **問題点**:
        - 取引を追加するだけの操作なのに、巨大な`顧客`オブジェクト全体をDBから取得・ロックする必要があり、パフォーマンスが著しく悪化する。
        - 複数のユーザーが同じ顧客の異なる取引を同時に更新しようとすると、ロックの衝突が頻発する。
- **ベストプラクティス: 集約を分割し、IDで関連付ける**
    - `顧客`と`取引`は別の集約として設計します。`取引`集約は`顧客ID`を保持して関連付けます。
    - 「取引を追加しても、顧客のステータスは即時変更されなくても良い」といった**結果整合性（Eventual Consistency）**で十分な場合が多いです。
    - **ルール**: 「本当に、このデータとあのデータは、1ナノ秒でもズレたらビジネスが成り立たないほど不可分か？」と自問自答します。答えがNoなら、それは別の集約にすべきです。

### Q6: リポジトリにはどんなメソッドを置くべき？
**A. 集約ルートを単位とした、基本的な永続化操作に限定すべきです。**

- **責務**: メモリ上にあるドメインオブジェクトと、データストア（DB）との間のマッピング。あたかもコレクションのように振る舞います。
- **ベストプラクティス**:
    - `findById(id)`: IDで集約を一つ取得する。
    - `save(aggregate)`: 集約を保存する（新規作成または更新）。
    - `delete(aggregate)`: 集約を削除する。
- **アンチパターン: UIのための検索メソッド**
    - `findByCustomerNameAndTransactionDateBetweenOrderByAmountDesc(...)`のような、特定の画面表示に特化した検索メソッドをリポジトリに追加すること。
    - **問題点**: プレゼンテーション層の要求がリポジトリ、ひいてはドメインモデルにまで影響を及ぼし、ドメイン層の純粋性が失われます。
- **解決策: CQRS (コマンド・クエリ責務分離)**
    - 更新系（コマンド）はDDDのモデルとリポジトリを経由します。
    - 参照系（クエリ）は、ドメインモデルを介さず、専用のクエリサービスが直接DBにアクセスして画面表示用のDTOを取得します。これにより、複雑な検索要件とドメインモデルを分離できます。

### Q7: 複数のサービスにまたがるデータの参照（クエリ）はどうすれば良い？
**A. いくつかのアプローチがありますが、API Gatewayによる集約が最も一般的なパターンです。**
- **背景**: マイクロサービスではデータが各サービスに分散しているため、例えば「顧客名と最新の取引履歴を一覧表示する」といった単純な画面でも、複数のサービス(`顧客サービス`と`口座サービス`)から情報を取得する必要があります。
- **パターン1: API Gatewayによる集約**
    - クライアントからのリクエストを単一の窓口であるAPI Gatewayが受け取ります。
    - API Gatewayは、リクエストに応じて必要な各マイクロサービスを呼び出し、その結果をクライアントが使いやすい形にマージして返します。
    - これにより、クライアントはバックエンドの複雑なサービス構成を意識する必要がなくなります。
    ```mermaid
    sequenceDiagram
        participant Client as クライアント
        participant Gateway as API Gateway
        participant CustomerSvc as 顧客サービス
        participant AccountSvc as 口座サービス

        Client->>Gateway: GET /customer-dashboard/{customerId}
        Gateway->>CustomerSvc: GET /customers/{customerId}
        CustomerSvc-->>Gateway: 顧客情報
        Gateway->>AccountSvc: GET /accounts?customerId={customerId}
        AccountSvc-->>Gateway: 口座情報・取引履歴
        Gateway->>Gateway: 顧客情報と口座情報をマージ
        Gateway-->>Client: ダッシュボード表示用データ
    ```
- **パターン2: CQRSビューの利用**
    - 参照専用のDB（Read Model Store）を用意するパターンです。
    - 各サービスは自身のデータ更新時にイベントを発行し、そのイベントを購読する専用のプロセッサが参照用DBを更新します。
    - 画面表示のリクエストは、この参照用DBに問い合わせるだけなので、非常に高速に応答できます。ただし、構成が複雑になり、データは結果整合性となります。

### Q8: サービス間で共通のDTOやイベントクラスはどう管理すべき？
**A. 共有ライブラリとして切り出し、バージョン管理するのが現実的です。**
- **課題**: `口座サービス`が発行する`AccountOpenedEvent`を`通知サービス`が購読する場合、両サービスで同じクラス定義が必要になります。これを各サービスで個別に定義すると、定義の同期が取れなくなり、デシリアライズエラーなどの問題が発生します。
- **解決策**:
    1. **共有ライブラリの作成**: イベントクラスや、サービス間でやり取りされるDTOのみを含む、独立したMaven/Gradleモジュール（例: `project-api-contracts`）を作成します。
    2. **バージョン管理**: この共有ライブラリは、セマンティックバージョニング（例: `1.0.0`, `1.1.0`）に従ってバージョンを付け、NexusやArtifactoryのようなリポジトリで管理します。
    3. **各サービスでの利用**: 各マイクロサービスは、`pom.xml`や`build.gradle`で、必要なバージョンの共有ライブラリを依存関係に追加します。
- **注意点**: 共有ライブラリにドメインロジックや実装を含めてはいけません。含めるのは、あくまでデータ構造を定義するクラス（`record`など）のみに限定し、サービス間の結合度を最小限に保つべきです。

### Q9: Sagaの途中で失敗した場合のデバッグや追跡はどうする？
**A. 分散トレーシングの仕組みを導入することが不可欠です。**
- **課題**: Sagaでは、一つのビジネスプロセスが複数のサービスにまたがるため、ログが各サービスに分散してしまいます。どこで処理が失敗したのかを追跡するのが非常に困難です。
- **解決策: 分散トレーシング (Distributed Tracing)**
    - **相関ID (Correlation ID)**: 最初のAPIリクエスト時に一意なID（相関ID）を生成し、それを後続のすべてのサービス呼び出し（HTTPヘッダーやイベントのメタデータ）に引き渡します。これにより、ログを集約した際に、特定のリクエストに関連するログだけをフィルタリングできます。
    - **ツール**: OpenTelemetryを標準とし、ZipkinやJaegerといったツールを導入することで、リクエストの流れを可視化し、各ステップの所要時間やエラー発生箇所を特定できます。

### Q10: ドメインイベントはどんな時に使うのが効果的？
**A. ある集約で起きたことを、別の集約や外部コンテキスト（特に別サービス）に通知したい時に使います。**

- **主な使いどころ**:
    - **コンテキスト間の連携**: 「口座コンテキスト」で`口座が開設された`イベントが発生したら、「通知コンテキスト」がそれを検知してウェルカムメールを送信する。
    - **結果整合性で良い処理の分離**: `取引`が完了した(トランザクションコミット)後、非同期で`監査ログ`を記録する。これにより、主要な取引処理の応答速度を向上させることができます。
    - **更新の副作用の通知**: ある処理が完了したことを、同じコンテキスト内の他の集約に伝える。
- **実装のヒント**: Spring Cloud Streamを使ってイベントを発行し、`Consumer` Beanで購読するのがマイクロサービス環境での標準的な方法です。

### Q11: 金額計算の注意点は？
**A. `double`や`float`は使わず、必ず`BigDecimal`を使います。** 浮動小数点数では丸め誤差が発生し、金融計算では致命的です。`Money`値オブジェクトに計算ロジックをカプセル化することで、この間違いを防ぎます。

### Q12: 排他制御はどのレイヤーの責務？
**A. 更新の衝突を検知する仕組みはリポジトリ層の責務です。衝突発生後の対応はアプリケーションサービスが担当します。**
- **リポジトリ (Infrastructure層)**:
    - `UPDATE`文の`WHERE`句に`version`を含めて更新します。
    - 更新件数が0件だった場合（＝衝突）、`OptimisticLockingFailureException`のような例外をスローします。
- **アプリケーションサービス (Application層)**:
    - リポジトリが投げた例外をキャッチします。
    - ユーザーに「他のユーザーによって更新されました。もう一度やり直してください」といったメッセージを返したり、場合によってはリトライ処理を行ったりします。 