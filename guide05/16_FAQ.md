# Chapter 16: FAQとトラブルシューティング

ドメイン駆動設計（DDD）を実践する旅は、多くの疑問や課題との遭遇の連続です。この章では、これまでのガイドで解説してきた内容を基に、開発者が実践の場で直面しがちな「よくある質問(FAQ)」と、問題解決のヒントとなる「トラブルシューティング」をまとめました。

---

## 16.1. 設計に関するFAQ

### Q1: バリデーションはどこに書くべきですか？

**A1:** バリデーションはその性質に応じて、適切な層に配置することが重要です。

1.  **構文的なバリデーション**:
    -   **内容**: `null`でないこと、文字列の形式（メールアドレスなど）、長さの制約など、単項目で完結するチェック。
    -   **場所**: **プレゼンテーション層 (Controller)** のDTO (`@Valid`とBean Validationを使用)。不正なリクエストをアプリケーションの入り口で弾きます。

2.  **ビジネスルールとしてのバリデーション**:
    -   **内容**: 「残高はマイナスになれない」「金利は0%以上でなければならない」といった、ビジネスの不変条件。
    -   **場所**: **ドメイン層 (値オブジェクト、エンティティ)**。値オブジェクトのコンストラクタや、エンティティのビジネスメソッド内に実装し、ドメインの健全性を常に保ちます。

3.  **複数集約にまたがるバリデーション**:
    -   **内容**: 「送金元と送金先の口座が存在するか」といった、複数の集約の状態に依存するチェック。
    -   **場所**: **アプリケーションサービス**。ユースケースの実行前に、リポジトリを使って関連する集約の状態を確認します。

### Q2: 値オブジェクトとエンティティはどう使い分ければ良いですか？

**A2:** **「識別子を持つかどうか」** が最も重要な判断基準です。

-   **エンティティ (Entity)**:
    -   **特徴**: 一意のIDを持ち、そのIDによってライフサイクルを通じて追跡されます。状態は可変です。
    -   **例**: `Customer` (顧客IDで識別)、`Account` (口座番号で識別)。
    -   **使い分け**: 時間の経過とともに状態が変化し、「どの顧客か」を区別する必要がある場合にエンティティとしてモデル化します。

-   **値オブジェクト (Value Object)**:
    -   **特徴**: 識別子を持たず、その属性値によって定義されます。**不変(Immutable)** であることが強く推奨されます。
    -   **例**: `Money` (金額と通貨)、`Address` (住所)。「100円」という値は誰のものであっても同じ「100円」です。
    -   **使い分け**: ある概念をその「値」で表現でき、不変である場合に値オブジェクトとしてモデル化します。これにより、システムの安全性が大幅に向上します。

### Q3: アグリゲートの適切な大きさは？

**A3:** **「小さく始め、トランザクションの一貫性境界に基づいて育てる」** のが原則です。

-   **アンチパターン**: 最初から多くのエンティティを含む巨大なアグリゲートを設計すると、パフォーマンスの低下や競合の増加、理解の困難さを招きます。
-   **推奨アプローチ**:
    1.  まずは単一のエンティティからなる最小のアグリゲートとして設計します。
    2.  ビジネスルールを実装する上で、「ある操作において、複数のオブジェクトが必ず**同時に**更新されなければならない（＝トランザクションの境界にある）」という強い一貫性要件が見つかった場合にのみ、それらのオブジェクトを同じアグリゲートに含めることを検討します。
    3.  それ以外のオブジェクト間の関連は、IDによる疎な関連付けとします。

---

## 16.2. アーキテクチャに関するFAQ

### Q4: 1つのトランザクションで複数のアグリゲートを更新したいです。

**A4:** これはDDDにおける非常に重要な問いであり、答えは **「原則として、それは避けるべき」** です。アグリゲートはトランザクションの一貫性境界そのものです。

もし複数のアグリゲートにまたがるビジネスプロセスが必要な場合は、**ドメインイベントと結果整合性 (Eventual Consistency)** のアプローチを採用します。

-   **例 (口座開設と顧客情報更新)**:
    1.  **口座サービス**が `Account` アグリゲートを作成し、ローカルトランザクションをコミットします。
    2.  成功したら `AccountOpenedEvent` を発行します。
    3.  **顧客サービス**がこのイベントを非同期で購読し、`Customer` アグリゲートの「開設口座数」を更新する、別のローカルトランザクションを開始します。

この設計により、各サービスの自律性が保たれ、システム全体のスケーラビリティと回復力が向上します。

### Q5: CQRS (コマンド・クエリ責務分離) は常に導入すべきですか？

**A5:** いいえ、必須ではありません。CQRSは強力なパターンですが、システムの複雑性を増大させるトレードオフも伴います。

-   **導入を検討するケース**:
    -   更新処理（コマンド）のモデルが非常に複雑だが、参照処理（クエリ）はシンプルな一覧表示でよい場合。
    -   参照系のパフォーマンス要件が非常に厳しく、更新系のデータベースとは別の、参照に最適化されたデータベース（リードレプリカ）が必要な場合。
-   **推奨アプローチ**: まずはコマンドとクエリで同じドメインモデルを共有するシンプルな構成から始めます。開発が進む中で上記の課題が顕在化してきた場合に、CQRSの導入を検討するのが現実的なアプローチです。

---

## 16.3. トラブルシューティング

### 問題1: ドメイン層のロジックをテストするのが難しい

-   **症状**:
    -   テストのためにデータベースや外部APIなど、多くの依存関係をセットアップする必要がある。
    -   モックが大量に発生し、テストコードが複雑で壊れやすい。
-   **診断**:
    -   **ドメイン層がインフラストラクチャ層に依存している**可能性が高いです。これはクリーンアーキテクチャの「依存性逆転の原則」に違反しています。
-   **処方箋**:
    -   **依存関係の方向を確認する**: `domain`パッケージ内のクラスが、`infrastructure`パッケージ内のクラスを`import`していないか確認します。
    -   **リポジトリの抽象化**: ドメイン層は、インフラストラクチャ層で実装された具象クラスではなく、自身で定義したインターフェース（抽象）にのみ依存するようにします。
    -   **Testcontainersの活用**: リポジトリなど、インフラ層のテストを行いたい場合は、実際のデータベース（PostgreSQLなど）を内包したコンテナをテスト実行時に起動する`Testcontainers`が非常に有効です。

### 問題2: サービス間の連携で意図しない不整合が頻繁に発生する

-   **症状**:
    -   あるサービスでの操作が、関連する他サービスに正しく反映されないことがある。
    -   Sagaプロセスが途中で失敗した際に、データの不整合（例：出金だけされて入金されない）が残ってしまう。
-   **診断**:
    -   Sagaの**補償トランザクション**が正しく実装されていない、または考慮漏れがある。
    -   サービス間の通信が「べき等（idempotent）」になっておらず、同じイベントを複数回受信した場合に問題が発生する。
    -   サービス間で期待されるデータの形式や意味（コントラクト）が曖昧である。
-   **処方箋**:
    -   **補償トランザクションの徹底**: Sagaの各ステップで、失敗した場合に状態を元に戻す補償アクションを必ず実装します。
    -   **べき等性の確保**: イベントのコンシューマー側で、一度処理したイベントIDを記録しておくなど、同じイベントを複数回処理しても結果が同じになるように設計します。
    -   **分散トレーシングの導入**: OpenTelemetry, Jaeger, Zipkinといったツールを導入し、複数のサービスをまたがるリクエストのフローを可視化することで、問題の特定が格段に容易になります。 