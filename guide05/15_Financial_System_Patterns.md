# Chapter 15: 金融システム特有の設計パターン

金融システムは、そのドメインの性質上、一般的なWebアプリケーションとは比較にならないほどの高い信頼性、一貫性、そしてセキュリティが求められます。わずかなデータの不整合やセキュリティの脆弱性が、甚大な金銭的損害や信頼の失墜に直結するためです。

本章では、これまでの章で学んだDDDの基本原則を基盤としつつ、金融システムの厳しい要件に応えるための特有の設計パターンを深く掘り下げて解説します。これらのパターンは、システムの堅牢性を高め、複雑なビジネスルールを正確にコードに落とし込むための実践的な武器となります。

---

## 15.1. 一貫性と整合性を守るパターン

金融ドメインの中核は「お金」と「取引」であり、その状態が一貫していることが絶対条件です。

### 15.1.1. アグリゲートによる強力な一貫性の境界

DDDにおける最も重要な原則の一つが **「一つのトランザクションでは、一つのアグリゲートインスタンスのみを変更する」** というルールです。

-   **なぜ重要か**: アグリゲートは、関連するオブジェクト群（エンティティと値オブジェクト）の一貫性を守るための境界です。例えば「口座」アグリゲートは、「残高はマイナスにできない」という不変条件（ビジネスルール）を常に維持する責任を持ちます。トランザクションを単一アグリゲートに限定することで、この不変条件が絶対に破られないことをデータベースレベルで保証できます。
-   **実装**: アプリケーションサービス層で、一度の操作で複数のアグリゲートを修正するロジックを書くべきではありません。もし複数のアグリゲートにまたがる操作が必要な場合は、次に説明するSagaパターンやドメインイベントを利用した結果整合性を検討します。

### 15.1.2. 楽観的ロックによる同時実行制御

複数のユーザーやシステムが同時に同じ口座の残高を更新しようとする「競合状態」は、金融システムにおいて致命的な問題を引き起こします。この「上書き損失」問題を効率的に解決するのが**楽観的ロック**です。

-   **仕組み**:
    1.  テーブルに`version`カラム（数値型）を追加します。
    2.  データを読み込む際に`version`の値も一緒に取得します。
    3.  データを更新する際、`UPDATE`文の`WHERE`句に`AND version = ?`という条件を加えます。
    4.  更新が成功した場合（更新件数が1件）、`version`を`+1`します。
    5.  更新が失敗した場合（更新件数が0件）、それは別のプロセスが先に更新したことを意味するため、トランザクションを失敗させ、リトライを促します。

-   **リポジトリでの実装**: リポジトリは、更新件数が0だった場合に`OptimisticLockingFailureException`のような例外をスローする責務を持ちます。

```java
// infrastructure.persistence.MyBatisAccountRepository
@Override
public void save(Account account) {
    // ...
    int updatedCount = accountMapper.update(account);
    if (updatedCount == 0) {
        throw new OptimisticLockingFailureException("Version mismatch for account " + account.getId());
    }
}
```
このパターンは、競合が稀なケースで高いスループットを維持するのに非常に有効です。

### 15.1.3. Sagaパターンによる分散トランザクション

マイクロサービスアーキテクチャでは、複数のサービス（＝複数のアグリゲート）にまたがるビジネスプロセスを単一のACIDトランザクションで扱うことはできません。この課題を解決するのが**Sagaパターン**です。

Sagaは、一連のローカルトランザクションの連鎖でビジネスプロセスを実現します。各ステップで失敗した場合、それまでの処理を取り消すための**補償トランザクション**を実行することで、プロセス全体としての一貫性を保ちます。
（コレオグラフィ型Sagaの実装例については、Chapter 12を参照してください。）

---

## 15.2. セキュリティと監査性を高めるパターン

### 15.2.1. 監査証跡 (Audit Trail) の実装

金融システムでは、「いつ、誰が、何を、どのように操作したか」を永続的に記録する監査証跡が法的に要求されることも少なくありません。この要件は、システムのビジネスロジックとは別の横断的な関心事です。

**Spring AOP (アスペクト指向プログラミング)** を利用することで、ビジネスロジックを汚すことなく監査ログ機能を実装できます。

1.  **`@Auditable`アノテーションの作成**: 監査対象のメソッドに付与します。
2.  **`AuditLogAspect`の作成**: `@Around`アドバイスを使い、アノテーションが付与されたメソッドの実行情報（ユーザー、メソッド引数、実行結果など）を取得し、専用のロガーやデータベースに記録します。

```java
@Aspect
@Component
public class AuditLogAspect {
    private static final Logger auditLogger = LoggerFactory.getLogger("audit");

    @Around("@annotation(auditable)")
    public Object logAudit(ProceedingJoinPoint joinPoint, Auditable auditable) throws Throwable {
        // セキュリティコンテキストから操作ユーザー情報を取得
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        
        Object result = joinPoint.proceed(); // メソッド本体の実行

        // ログの記録
        auditLogger.info("Action: [{}], User: [{}], Args: {}", 
            auditable.action(), username, joinPoint.getArgs());
        
        return result;
    }
}
```
これにより、監査という要件をアプリケーション全体に宣言的に適用できます。

### 15.2.2. 値オブジェクトによる不正値の防止

セキュリティは、入力検証ゲートウェイだけでなく、ドメインモデルの内部でも確保されるべきです。**値オブジェクト**は、この「ドメインレベルのセキュリティ」を実現する強力なパターンです。

-   **例: `Money`オブジェクト**:
    -   コンストラクタで「金額がマイナスでないこと」「通貨コードがISO形式であること」を検証します。
    -   一度生成されたら不変であるため、意図しない変更を防ぎます。
    -   `add`や`subtract`といった操作のみを許可し、不正な計算を防ぎます。

-   **例: `EmailAddress`オブジェクト**:
    -   コンストラクタで正規表現によるフォーマット検証を行います。

```java
public record Money(BigDecimal amount, Currency currency) {
    public Money {
        Objects.requireNonNull(amount);
        Objects.requireNonNull(currency);
        if (amount.signum() < 0) {
            throw new IllegalArgumentException("Amount cannot be negative.");
        }
    }
    // ... add, subtract, etc.
}
```

値オブジェクトを使うことで、「不正な値はそもそも存在し得ない」という状態を設計レベルで保証し、システムの堅牢性を格段に向上させます。

## 15.3. まとめ

本章で紹介したパターンは、複雑で要求の厳しい金融システムの開発において、DDDを適用する際の具体的な道しるべとなります。アグリゲートによる一貫性の確保、楽観的ロックによる安全な同時実行、Sagaによる分散環境での信頼性、そしてAOPや値オブジェクトによるセキュリティと監査性の向上。これらのパターンを組み合わせることで、変化に強く、堅牢で、ビジネス価値を正確に反映したソフトウェアを構築することが可能になります。 