ドメイン駆動設計による堅牢な金融システムの設計：必須クラス構造ガイド




1. はじめに：金融DDDにおける明確に定義されたクラスの必要性


金融システムは、その本質から複雑であり、複雑な規制、多様な金融商品、重要なセキュリティ要件、そして高い精度への要求といった課題に対応する必要があります 1。従来の開発アプローチでは、この複雑性を管理するのに苦労し、理解、保守、進化が困難なシステムを生み出す可能性があります 1。実際に、従来の手法では「ビジネス要件との乖離」や「複雑性の増大」といった問題が指摘されています 1。金融業務は一見単純に見えるかもしれませんが、その背後には「複雑なオペレーションの領域」が隠されており、ドメイン駆動設計（DDD）はこれらの「入り組んだ金融タスクを、よく整理され、管理可能なソリューションへと変換する」のに役立ちます 2。
ドメイン駆動設計（DDD）は、ビジネスの中核となるドメインとドメインロジックに焦点を当て、ビジネスへの深い理解を構築する戦略的ソリューションです 3。DDDは、ドメインエキスパートと開発者の協調作業を重視します 1。このアプローチは、「業務の要件やビジネスルールに重きをおいた設計」を行うことを特徴としています 4。また、DDDは「ソフトウェア設計の中核をドメイン（業務領域）の知識に据え」るものです 5。DDDの目標は、ビジネスの複雑性をソフトウェアに正確に反映させることです 1。
DDDにおいて、クラスは単なるデータコンテナではなく、ドメインの概念を豊かに表現し、状態と振る舞いの両方をカプセル化します 3。戦術的DDDパターンに基づいて明確に定義されたクラスは、堅牢で表現力豊かで保守性の高いドメインモデルの構成要素となります。これらのクラスは、ビジネスの理解を実際に動作するソフトウェアの成果物へと翻訳します。DDDは、「ドメインモデルをコードに落とし込むこと」を目指し、コードは「モデルをそのまま表現する」ものとなります 3。
金融システムの文脈でDDDにおけるクラスの構造と責務を考えるとき、それは単なるコードの整理を超えた意味を持ちます。これらのクラスは、チームの金融ドメインに対する理解度を具体的に示すものとなります。DDDは、ビジネスの現実を反映した豊かなドメインモデルの作成を重視します 1。このモデルは、主にエンティティや値オブジェクトといったクラスを通じてコードで表現されます 3。したがって、これらのクラスの設計（名称、属性、メソッド、関連性）は、チームによる金融ドメインの解釈を具体化したものとなります。金融の概念が誤解されたり、過度に単純化されたりすると、結果として得られるクラスは貧弱で不適切なものとなり、ロジックが誤った場所に配置され、システムをビジネスニーズに整合させることがより困難になります。逆に、振る舞いが豊富でドメインの概念を正確に反映した、うまく作られたクラスは、深く共有された理解を示し、より良いコミュニケーションとより回復力のあるシステムを促進します。これは、「ドメインモデルは技術仕様ではなく、業務の概念を表現したもの」であるという考え方の直接的な帰結です 3。


2. クラス設計を導く基本的なDDD原則




2.1. ドメインモデル：システムの知識の中核


ドメインモデルとは、ビジネスドメインの抽象化であり、その概念、ルール、振る舞いを捉えたものです 1。これは単なるデータモデルではなく、プロセスやロジックも含みます。金融においては、このモデルは口座、取引、顧客、金融商品、リスクポリシーといった概念を表すかもしれません。クラスは、オブジェクト指向パラダイムにおいてドメインモデルを実装する主要な手段です。
DDDとは、「ドメイン（＝対象とする業務の世界やコンテキスト）を把握した上で、その知識を材料にプロダクトの扱う業務仕様をドメインモデルとして練り上げ、そのモデルを動くソフトウェアに落とし込むこと」であるとされています 3。ドメインモデルは、「ビジネスの概念、ルール、およびそれらの関係性や振る舞いをオブジェクトとして明確に定義します」 1。このドメインモデルが、クラスが導き出される設計図となるのです。


2.2. ユビキタス言語：クラスの命名と定義における協調作業


ユビキタス言語とは、ドメインエキスパートと開発者が共有する言語であり、あらゆるコミュニケーションやコード（クラス名、メソッド名、プロパティ）で使用されます 1。これは、誤解を避け、ソフトウェアがビジネスドメインを正確に反映することを保証するために不可欠です。金融用語は正確かつ微妙なニュアンスを持つことがあります（例：「決済 (settlement)」と「清算 (clearing)」）。ユビキタス言語はこれらの区別を捉えなければなりません。
ユビキタス言語は、「各領域で共通の用語を用いることで、認識の齟齬を産まないようにしようね」という考え方に基づいています 4。金融システムにおけるその利点は、「複雑なビジネスルールを明確化し、開発の効率化と正確性を実現した事例があります」という報告にも示されています 7。この共通言語は、「モデルのクラス名やメソッド名にも反映され」ます 1。これにより、クラスとそのメンバーがどのように命名され、理解されるかに直接的な影響を与えます。


2.3. 境界づけられたコンテキスト：クラスモデルの明確な境界と責務の設定


境界づけられたコンテキストは、特定のドメインモデル（およびそのユビキタス言語）が一貫性を持ち、曖昧さなく適用される特定の境界を定義します 1。大規模な金融システムは通常、複数の境界づけられたコンテキスト（例：「口座管理」「融資実行」「リスク評価」「支払処理」）に分解されます。
Accountのようなクラスは、「顧客サービス」コンテキストと「元帳」コンテキストでは異なる属性や振る舞いを持つ可能性があります。
境界づけられたコンテキストは、「あるモデルやユビキタス言語が適用できるコンテキストを明確にする」ものです 3。「同じ単語でもコンテキストが異なれば、別の概念を表した異なるユビキタス言語となる」ことがあります 8。これにより、ドメインを「管理しやすい小さな単位に分割して集中する」ことで複雑性を管理します 1。これは、クラス設計がコンテキスト固有であり、大規模な金融システム全体で画一的なアプローチを採ることを防ぐことを意味します。
金融におけるクラス設計において、ユビキタス言語と境界づけられたコンテキストの間には共生関係が存在します。境界づけられたコンテキストの明確さは、そのユビキタス言語の精度に正比例し、逆もまた同様です。金融では、「顧客」という用語が個人顧客を指す場合もあれば、機関投資家を指す場合もあるなど、用語が多義的に使われることがあります。これらの用語を、明確なユビキタス言語を用いて特定の境界づけられたコンテキスト内で区別しなければ、曖昧なクラス設計や統合上の問題を引き起こしかねません。金融システムは大規模かつ多面的です 1。このようなシステムに対して単一の統一モデルを持つことは非現実的であり、混乱を招きます 10。境界づけられたコンテキストは、システムを管理可能な部分に分割し、それぞれが独自のモデルを持つ方法を提供します 1。各境界づけられたコンテキスト内では、ユビキタス言語がその特定モデルの明確性と一貫性を保証します 1。例えば、「口座」や「取引」といった金融用語は、銀行の異なる部門（例：トレーディング部門とリテールバンキング部門）では異なる意味や焦点を持つ可能性があります。これらの用語が境界づけられたコンテキストという明確な境界なしにクラス名として使用されると、結果として得られる
Accountクラスは、関連性のない多くの責務を包含しようとし、肥大化し、まとまりがなくなる可能性があります。境界づけられたコンテキスト（例：「トレーディング口座管理」）を定義する行為は、チームにその特定のコンテキスト内での「口座」に関するユビキタス言語を洗練させることを強い、より焦点の定まった適切なTradingAccountクラスの設計につながります。したがって、クラスの設計は単に戦術的なパターンに関するものではなく、これらの戦略的な設計決定に深く影響されます。「ユビキタス言語はコンテキスト中で閉じる」という考え方が示すように 8、明確に定義された境界づけられたコンテキストとその関連するユビキタス言語は、有意義で効果的なクラスを設計するための前提条件です。


3. 中核となる戦術的DDDパターン：クラスの特定と構造化


戦術的DDDは、ドメインモデルを構築するための一連のパターンを提供します。これらのパターンは、ビジネスドメインと整合した、豊かで表現力豊かなクラスの作成を導きます 10。戦略的設計がシステムの分割に関わるのに対し、戦術的設計は「1つのアプリケーションを具体的にどう実装するかというテクニックの話」です 11。戦術的DDDでは、「ドメインモデルをより正確に定義します」 10。


3.1. エンティティ：一意のアイデンティティとライフサイクルを持つオブジェクトの表現


エンティティは、その属性だけでなく、一意の識別子によって区別されるオブジェクトです 10。このIDは、エンティティのライフサイクルを通じて一定です。エンティティは可変であり、その属性は時間とともに変化する可能性があります 10。エンティティは作成、変更、そして潜在的には削除されるというライフサイクルを持ちます。また、他のエンティティへの参照を保持することができます 10。
金融における一般的なエンティティには以下のようなものがあります。
* Customer（顧客）：CustomerIDによって識別されます。氏名、住所、連絡先などの属性は変更される可能性がありますが、顧客は同じ個人または組織であり続けます 10。
* Account（口座）：AccountNumberによって識別されます。残高、ステータス、取引履歴はそのライフサイクルを通じて変化します 10。
* Loan（ローン）：LoanIDによって識別されます。元本、発生利息、ステータス（例：アクティブ、デフォルト、完済）が変化します。
* TransactionRecord（取引記録）：TransactionIDによって識別されます。預金、引き出し、振替などの特定の金融イベントを表します。
* FinancialInstrument（金融商品）：ISINやCUSIPによって識別されます。株式、債券、デリバティブなどが該当し、市場価格やその他の属性が変化します。
10は、「エンティティに一意識別子が割り当てられており...属性は時間の経過と共に変わる可能性があります」と明確に定義しています。10もこれを繰り返し、銀行アプリケーションの例として「顧客」と「口座」を挙げています。13では、
CustomerとAccountが集約ルート（エンティティの一種）として、CreditとDebitがAccount集約内のエンティティとしてリストされています。エンティティは、継続性と履歴を持つ中核的なビジネスオブジェクトを表すドメインモデルのバックボーンです。


3.2. 値オブジェクト：属性と概念の記述


値オブジェクトは、その属性によって定義され、概念的なアイデンティティを持ちません 10。同じ属性を持つ2つの値オブジェクトは等しいと見なされます。値オブジェクトは不変であり、一度作成されるとその状態を変更することはできません。変更するには、新しいインスタンスを作成する必要があります 10。これにより、予測可能性とスレッドセーフティが向上します。値オブジェクトは、ドメインの記述的な側面を表すことが多く、その概念に関連するロジック（例：
Moneyオブジェクト内の通貨換算）をカプセル化できます。
金融における必須の値オブジェクトには以下のようなものがあります。
* Money（金額）：amount（例：精度を保つためのBigDecimal）とcurrency（例："USD", "JPY"）で構成されます。すべての金融取引に不可欠です 2。
* Address（住所）：通り、市、郵便番号、国。
* InterestRate（利率）：パーセンテージ値、計算タイプ（例：単利、複利）。
* TransactionType（取引種別）：例：「預入」「引出」「振替」。
* PolicyNumber（保険証券番号）：保険契約を識別する一意の文字列ですが、番号自体は値です。
* DateRange（期間）：開始日と終了日。
* CurrencyPair（通貨ペア）：例：USD/JPY。
10は、値オブジェクトを「IDを持たず、その属性の値のみで定義されるオブジェクト」であり、「不変（immutable）」であると定義しています。2は、金融において
Moneyが極めて重要な値オブジェクトであり、不変性、精度、通貨処理を強調しています。22は、「値オブジェクトを使えば、たとえば UserId と UserName で型が異なるため、誤代入を防ぐことができます」という実用的な利点を示しています。値オブジェクトは、明確性をもたらし、プリミティブ型への執着を減らし、特定のルールを持つ概念が一貫して扱われることを保証します。


3.3. 集約：エンティティと値オブジェクトをグループ化し、一貫性を維持


集約とは、データの変更という目的において単一のユニットとして扱われる、関連するエンティティと値オブジェクトのクラスターです 7。集約内の1つのエンティティが集約ルートとして指定され、外部オブジェクトが参照を保持できる唯一のメンバーとなります。集約の任意の部分への変更は、集約ルートを通じて開始されます。
集約は一貫性の境界を定義します。集約内の複数のオブジェクトにまたがるビジネスルール（不変条件）は、集約ルートによって強制されます 16。集約内のすべてのオブジェクトは、通常、単一のトランザクション内で一緒にロードされ、保存されます。
金融における集約の例：
* Account（口座）集約：
   * ルート：Account（エンティティ）。
   * 内部：Transactionのリスト（値オブジェクト、または口座コンテキスト内で独自のライフサイクル/アイデンティティを持つ場合はエンティティ）、Balance（値オブジェクト）。
   * 不変条件：口座残高は特定の当座貸越限度額を下回ってはならない。すべての取引は有効でなければならない。
* Customer（顧客）集約：
   * ルート：Customer（エンティティ）。
   * 内部：Address（値オブジェクト）、ContactDetails（値オブジェクト）、NotificationPreferenceのリスト（値オブジェクト）。
   * 不変条件：顧客は少なくとも1つの主要な連絡方法を持たなければならない。
* LoanApplication（ローン申請）集約：
   * ルート：LoanApplication（エンティティ）。
   * 内部：ApplicantDetails（値オブジェクト）、RequestedLoanAmount（Money VO）、Collateral（値オブジェクトのリスト、または複雑な場合はエンティティ）。
   * 不変条件：ローン金額は申請者の収入に対して許容範囲内でなければならない。
* TradingOrder（取引注文）集約：
   * ルート：Order（エンティティ）。
   * 内部：FinancialInstrument（値オブジェクトまたはIDによる参照）、OrderQuantity（値オブジェクト）、OrderPrice（Money VO）、OrderStatus（値オブジェクト）。
   * 不変条件：注文数量は正でなければならない。「売り」注文の場合、口座はその商品の十分な数量を保有していなければならない。
7は、データの一貫性のために「アグリゲートを用いたシステム設計」に言及しています。10は、集約を「一貫性の境界」を定義し、1つのエンティティを「ルート」とするものとして説明しています。16は、不変条件がユビキタス言語で表現されるビジネスルールであり、集約内に隠蔽されるべきである（「詳細は集約で隠蔽化されるべきです」）と強調しています。23は、フィンテックの文脈でArkencyがどのように「集約を導入し、厳格なビジネスルールを適用して誤分類を防止したか」に言及しています。集約は、金融システムにおけるデータ整合性の維持と複雑なビジネスルールのカプセル化に不可欠です。


3.4. ドメインサービス：単一のエンティティ/値オブジェクトに属さないドメインロジックのカプセル化


ドメインロジックの一部が単一のエンティティや値オブジェクトに自然に適合しない場合、ドメインサービスを使用します。これは多くの場合、複数の集約間の調整や、いくつかのドメインオブジェクトに基づく計算を含みます。ドメインサービスは通常ステートレスです。
金融における例：
* FundTransferService（資金振替サービス）：2つのAccount集約間の振替を調整します。一方の口座から引き落とし、もう一方の口座に入金し、一部が失敗した場合の原子性または補償ロジックを保証します。
* RiskAssessmentService（リスク評価サービス）：Customerのプロファイル、口座履歴、外部の信用スコアに基づいて信用リスクを計算します。これには複数の集約が関与する可能性があります。
* LoanOriginationService（ローン組成サービス）：LoanApplicationからLoanを作成するプロセスを管理し、信用調査や担保評価などを含む場合があります。
* CurrencyConversionService（通貨換算サービス）：ある通貨の金額を別の通貨に換算し、場合によっては外部の市場レートを使用します。
10は、ドメインサービスが「ドメインロジック」をカプセル化し、多くの場合「複数のエンティティにまたがる動作のモデル化に使われます」と説明しています。ドメインサービスは、エンティティや値オブジェクトが本来の関心事ではない責務で肥大化するのを防ぎ、モデルをクリーンに保ちます。


3.5. リポジトリ：集約の永続化と取得の管理


リポジトリは、ドメインモデルとデータ永続化メカニズム（例：データベース）の間に抽象化レイヤーを提供します。これにより、集約のインメモリコレクションのような幻想を与えます。クライアント（例：アプリケーションサービス）は、IDまたは特定のクエリ基準を使用してリポジトリから集約を要求します。リポジトリは集約ルートを扱うように設計されており、通常、集約タイプごとに1つのリポジトリが存在します。
リポジトリのインターフェースはドメインレイヤーで定義され、インフラストラクチャレイヤーで実装されます（依存性逆転の原則）。一般的なメソッドには、findById(id)、save(aggregate)、delete(aggregate)、および集約に固有のクエリメソッド（例：findAccountsByCustomerId(customerId)）が含まれます。
金融における例：
* IAccountRepository: Account getAccount(AccountNumber accountNumber); void save(Account account);
* ICustomerRepository: Customer getCustomer(CustomerId customerId); List<Customer> findCustomersByName(String name);
* ILoanRepository: Loan getLoan(LoanId loanId); void save(Loan loan);
10は、リポジトリをマイクロサービス実装に役立つDDDパターンとして言及していますが、詳細は述べていません。10もリポジトリを「役立つパターン」としてリストアップしています。3は、「インフラ層 (DBとか)」が分離されており、「ドメイン層は他のどの層にも依存しない」ことを示しており、これはリポジトリがドメイン内のインターフェースであり、実装がインフラストラクチャにあるという考え方と一致します。リポジトリは、ドメインモデルを永続化の懸念から切り離し、テスト容易性と柔軟性を向上させます。


3.6. ファクトリ：複雑なオブジェクト作成の単純化


エンティティまたは集約の作成が複雑であるか、作成時に不変条件を強制する必要がある場合、ファクトリを使用します。ファクトリは作成ロジックをカプセル化し、オブジェクトが常に有効な状態で作成されることを保証します。
金融における例：
* AccountFactory（口座ファクトリ）：顧客情報、口座タイプ、初期預金を受け取り、新しい口座を開設するためのすべてのビジネスルールが満たされていることを確認してから、新しいAccount集約を返すかもしれません。例えば、顧客が特定の口座タイプに適格であるかどうかを確認します。
* LoanApplicationFactory（ローン申請ファクトリ）：LoanApplicationの初期作成を処理し、必要なすべての予備情報が提供され、初期の検証ルールがパスされることを保証します。
* FinancialInstrumentFactory（金融商品ファクトリ）：作成に特定のルールとパラメータが関与する複雑なデリバティブ商品を作成するために使用されます。
5と5は、ファクトリを「複雑なオブジェクトの生成ロジック」をカプセル化し、「オブジェクトの一貫性を維持するために利用されるパターンです」と説明しています。5は
OrderFactoryの例を提供しており、これは金融ファクトリがどのように機能するかに類似しています。ファクトリは、複雑なドメインオブジェクトが常に正しくインスタンス化され、最初からその不変条件が維持されることを保証します。


表1：クラス設計のための戦術的DDD構成要素の概要




パターン
	中核となる責務
	主な特徴
	金融システム例（クラス）
	エンティティ
	明確なアイデンティティとライフサイクルを持つオブジェクトを表す。
	一意のID、可変、ライフサイクル、履歴。
	Account、Customer、Loan、TransactionRecord
	値オブジェクト
	属性や概念を記述する。測定または定量化する。
	IDなし、不変、属性値に基づく等価性、自己検証。
	Money、Address、InterestRate、CurrencyCode
	集約
	エンティティとVOを整合性の境界にグループ化する。
	集約ルートがエントリポイント、不変条件を強制、トランザクション整合性。
	Account（Transaction群を含む）、LoanApplication
	ドメインサービス
	単一のオブジェクトに適合しないドメインロジックをカプセル化する。
	ステートレス、複数の集約/エンティティを調整、多くの場合複雑な操作のため。
	FundTransferService、RiskCalculationService
	リポジトリ
	集約の永続化と取得を管理する。
	ドメイン内のインターフェース、インフラ内の実装。データアクセスを抽象化。コレクションのようなインターフェース。
	IAccountRepository、ILoanRepository
	ファクトリ
	複雑なオブジェクト作成を単純化し、妥当性を保証する。
	作成ロジックをカプセル化し、インスタンス化時に不変条件が満たされることを保証する。
	AccountFactory、LoanProductFactory
	金融モデリングにおける戦術的パターンの選択、例えばある概念がエンティティなのか値オブジェクトなのか、あるいは集約の範囲をどのように設定するかといった判断は、常に白黒はっきりしているわけではなく、進化する可能性があります。例えば、Account内のTransactionは、単純でその口座にのみ関連する場合、最初は値オブジェクトとして扱われるかもしれません。しかし、Transactionを独立して照会する必要が生じたり、口座を横断して監査したり、独自の複雑なライフサイクル（例：係争中の取引）を持つようになったりした場合、Transactionはエンティティへと進化し、場合によっては「取引処理」境界づけられたコンテキスト内でそれ自体が集約ルートになる可能性さえあります。この流動性が鍵となります。
戦術的DDDはエンティティ、値オブジェクト、集約といったパターンを提供します 10。これらのパターンの初期適用は、ドメインの現在の理解に基づきます。金融ドメインは複雑であり、進化する要件を持つ可能性があります 1。例えば、規制報告のニーズが変化し、特定の概念についてより詳細な追跡が必要になるかもしれません。
Transactionオブジェクトを考えてみましょう。当初、Account集約内では、そのアイデンティティが純粋に口座にローカルであり、属性が単純（例：金額、日付、説明）であれば、ValueObjectとしてモデル化されるかもしれません。しかし、ビジネス要件が変化し、例えば個々の取引のステータス（保留中、クリア済み、失敗、係争中）を追跡したり、外部の決済システムにリンクしたり、グローバルに監査したりする必要が生じた場合、単純なValueObjectでは不十分になります。そのようなシナリオでは、Transactionは独自のアイデンティティとライフサイクルを必要とし、Entityとなります。これらのTransactionエンティティが十分に複雑になり、Accountとは独立して独自の不変条件を強制する必要が生じた場合、それらは独自の集約ルートとなり、ITransactionRepositoryによって管理されることさえあります。これは、Transactionが中心的な概念となる別の「支払処理」境界づけられたコンテキストで起こり得ます。これは、戦術的パターンの適用が静的なものではないことを示しています。それは境界づけられたコンテキストと解決すべき特定の問題に依存するモデリングの選択です。「正しい」設計は、多くの場合、反復とドメインニーズのより深い理解を通じて現れます。これは、3の「対話から得た知識や洞察をモデルに反映する」というループが示唆するところです。したがって、開発者はこれらのパターンを固定的な型としてではなく、柔軟なツールとして捉えるべきです。特に金融のようなダイナミックな分野では、ドメインの理解が深まったり要件が進化したりするにつれて、初期のクラス構造は洗練が必要になるかもしれません。


4. 主要な金融サブドメインにおける具体的なクラス構造例


このセクションでは、戦術的DDDパターンが特定の金融分野内でクラスとしてどのように具体化されるかについて、より具体的な例を示します。これはセクション3で議論された一般的なパターンに基づいています。


4.1. 口座管理サブドメイン


* 中核となる集約： Account（口座）
   * ルートエンティティ： Account (クラス: Account.java または Account.cs)
      * プロパティ： AccountNumber (VO), AccountHolderId (VO, 顧客へのリンク), AccountType (VO: SAVINGS, CHECKING), Balance (Money VO), AccountStatus (VO: ACTIVE, DORMANT, CLOSED)
      * メソッド： deposit(Money amount), withdraw(Money amount), checkBalance(), applyInterest(InterestRate rate), closeAccount()。不変条件（例：残高＋当座貸越を超えない引き出し）はここで強制されます。
* Account集約内の内部エンティティ/値オブジェクト：
   * Transaction (クラス: Transaction.java または Transaction.cs - VOまたはエンティティの可能性あり)
      * プロパティ： TransactionId (VO, エンティティの場合), TransactionDate (VO), TransactionType (VO), Amount (Money VO), Description (String)
   * OverdraftPolicy (クラス: OverdraftPolicy.java - VO)
      * プロパティ： OverdraftLimit (Money VO), Fees (Money VO)
* リポジトリ： IAccountRepository
* ファクトリ： AccountFactory（例：特定の初期条件やタイプの口座を作成するため）
* 関連情報源： 10 (
Accountをエンティティとして言及), 13 (
BankAccountとMoneyに関連するコード例を提供), 24 (
Wallet.javaは口座のような構造を示唆)


4.2. 顧客管理サブドメイン（KYC/CRMフォーカス）


   * 中核となる集約： Customer（顧客）
   * ルートエンティティ： Customer (クラス: Customer.java または Customer.cs)
   * プロパティ： CustomerId (VO), CustomerType (VO: INDIVIDUAL, CORPORATE), LegalName (String), Status (VO: ACTIVE, PENDING_VERIFICATION, SUSPENDED)
   * メソッド： updateAddress(Address newAddress), addContactMethod(ContactMethod contact), verifyIdentity(KYCDocument document), flagForReview()
   * Customer集約内の内部エンティティ/値オブジェクト：
   * Address (クラス: Address.java - VO)
   * プロパティ： street, city, postalCode, country
   * ContactMethod (クラス: ContactMethod.java - VO)
   * プロパティ： type (VO: EMAIL, PHONE), value (String), isPrimary (boolean)
   * KYCInformation (クラス: KYCInformation.java - VOまたは複雑なライフサイクルを持つ場合はエンティティ)
   * プロパティ： DocumentType (VO), DocumentNumber (String), VerificationDate (Date VO), RiskRating (VO)
   * リポジトリ： ICustomerRepository
   * 関連情報源： 10 (
Customerをエンティティとして言及), 9 (DDDの恩恵を受ける顧客管理システムについて言及)


4.3. ローン処理サブドメイン


      * 中核となる集約： LoanApplication（ローン申請）、Loan（ローン）
      * 集約1： LoanApplication
      * ルートエンティティ： LoanApplication (クラス: LoanApplication.java)
      * プロパティ： ApplicationId (VO), ApplicantId (VO, 顧客へのリンク), RequestedAmount (Money VO), LoanPurpose (String), Status (VO: SUBMITTED, UNDER_REVIEW, APPROVED, REJECTED)
      * メソッド： submit(), approve(ApprovedLoanTerms terms), reject(String reason), addSupportingDocument(Document doc)
      * 集約2： Loan（多くの場合、承認されたLoanApplicationから作成される）
      * ルートエンティティ： Loan (クラス: Loan.java)
      * プロパティ： LoanId (VO), OriginalPrincipal (Money VO), CurrentPrincipal (Money VO), InterestRate (InterestRate VO), TermInMonths (int), RepaymentSchedule (RepaymentSchedule VO), Status (VO: ACTIVE, PAID_OFF, DEFAULTED)
      * メソッド： makeRepayment(Money amount), accrueInterest(), restructureLoan(NewTerms terms)
      * 値オブジェクト： RepaymentSchedule（ScheduledPayment VOのリストを含む）、ApprovedLoanTerms
      * リポジトリ： ILoanApplicationRepository, ILoanRepository
      * ドメインサービス： LoanOriginationService（申請からローンへの移行を管理）、CreditScoringService
      * 関連情報源： 25 (デジタルモーゲージに言及、ローン処理を示唆), 18 (一般的なDDD用語でローン/融資システムについて議論)


4.4. 決済システムサブドメイン


      * 中核となる集約： PaymentOrder（支払指図）または PaymentTransaction（支払取引）
      * ルートエンティティ： PaymentOrder (クラス: PaymentOrder.java)
      * プロパティ： PaymentOrderId (VO), PayerAccountId (VO), PayeeAccountId (VO), Amount (Money VO), PaymentMethod (VO: TRANSFER, CARD), Status (VO: PENDING, PROCESSING, COMPLETED, FAILED), ExecutionDate (Date VO)
      * メソッド： initiate(), process(), complete(), fail(String reason)
      * 値オブジェクト： PaymentInstrumentDetails（例：カード番号ハッシュ、銀行口座詳細 - セキュリティに注意して処理）
      * リポジトリ： IPaymentOrderRepository
      * ドメインサービス： PaymentExecutionService（外部決済ゲートウェイ/ネットワークと対話）、FraudDetectionService
      * 関連情報源： 26 (決済プラットフォームにおける
Payment集約とPaymentCardエンティティについて言及), 23 (Trezyのケーススタディは取引分類と処理を含む)


表2：主要な金融サブドメインにおけるクラス分類例




金融サブドメイン
	代表的な集約ルート（エンティティクラス）
	集約内の主要エンティティ（クラス）
	重要な値オブジェクト（クラス）
	口座管理
	Account
	Transaction（エンティティの場合）
	AccountNumber, Money（残高用）, AccountType, AccountStatus, TransactionDetails（VOの場合）
	顧客管理
	Customer
	KYCDocument（ライフサイクルを持つエンティティの場合）
	CustomerId, Address, ContactMethod, CustomerStatus, RiskLevel
	ローン処理
	LoanApplication, Loan
	CollateralItem（エンティティの場合）
	ApplicationId, LoanId, Money（金額用）, InterestRate, LoanTerm, RepaymentSchedule
	決済システム
	PaymentOrder
	PaymentAttempt（エンティティの場合）
	PaymentOrderId, Money（金額用）, PaymentMethodType, PaymentStatus, BankRoutingNumber
	境界づけられたコンテキストは分離を促進しますが、金融プロセスはしばしば複数のサブドメインにまたがります。これは、あるサブドメインのクラス（例：決済のPaymentOrder）が、別のサブドメインの集約の識別子（値オブジェクト）（例：口座管理のAccountNumber、顧客管理のCustomerId）を頻繁に参照することを意味します。これらの識別子VOの設計と、それらを解決するためのメカニズム（例：アプリケーションサービスまたはドメインイベント経由）は、コンテキスト間の通信にとって極めて重要になります。金融システムは通常、口座管理や決済といったサブドメイン/境界づけられたコンテキストに分割されます 17。各サブドメインは、前述のように独自のクラスセット（集約、エンティティ、VO）を持ちます。しかし、ローン返済のような完全な金融取引は、「ローンサービシング」コンテキストで発生するかもしれませんが、「口座管理」（顧客口座からの引き落とし）や「支払処理」（振替の実行）でアクションを引き起こす可能性があります。「ローンサービシング」における
LoanRepaymentイベントまたはコマンドは、特定のLoan（例：LoanIdによる）と引き落とし元のAccount（例：AccountNumberによる）を参照する必要があります。LoanIdとAccountNumberは、それぞれの境界づけられたコンテキスト内の集約の安定した識別子として機能する値オブジェクトです。したがって、ある境界づけられたコンテキストのクラス（例：ローン返済を処理するアプリケーションサービス）は、これらのID VOを使用して、他の境界づけられたコンテキストによって管理される概念を参照します。これらのVOの設計は、コンテキスト間の参照に使用される場所で一貫している必要があります。これは、完全なAccountクラスモデルは口座管理コンテキストに固有である一方、そのAccountNumber VOは他のコンテキストで使用される共有言語（またはその契約の公開された部分）の一部であることを意味します。これは、境界づけられたコンテキスト間の「継ぎ目」を慎重に設計することの重要性を浮き彫りにし、多くの場合、集約IDがVOとしてどのように表現され、伝達されるかに現れます。


5. ドメインイベント：重要な出来事をクラスとしてモデリング


ドメインイベントとは、ドメイン内で何か重要なことが起こったことを示すクラスです 5。これらは事実であり、過去形で命名されます（例：
AccountOpened、PaymentFailed）。ドメインイベントは、境界づけられたコンテキストを分離し、結果整合性を可能にし、副作用や下流プロセスをトリガーするために不可欠です 5。
ドメインイベントクラスは通常不変であり、イベントに関連するデータを含みます（例：AccountOpenedEventはAccountNumber、CustomerId、OpeningDateを保持します）。これらは単純なデータ構造（POJO/POCO）である可能性があります。
金融におけるドメインイベントクラスの例：
         * AccountOpenedEvent { AccountNumber accountNumber; CustomerId customerId; Instant openedAt; Money initialDeposit; }
         * FundsDepositedEvent { AccountNumber accountNumber; Money amountDeposited; Instant transactionTime; TransactionId depositId; }
         * FundsWithdrawnEvent { AccountNumber accountNumber; Money amountWithdrawn; Instant transactionTime; TransactionId withdrawalId; }
         * PaymentExecutedEvent { PaymentOrderId paymentOrderId; Money amount; Instant executionTime; PaymentStatus status; }
         * PaymentFailedEvent { PaymentOrderId paymentOrderId; String reason; Instant failureTime; }
         * LoanApplicationSubmittedEvent { ApplicationId applicationId; CustomerId applicantId; Money requestedAmount; }
         * LoanApprovedEvent { LoanId loanId; ApplicationId applicationId; Money approvedAmount; InterestRate rate; }
         * InterestAccruedEvent { AccountNumber accountNumber; Money interestAmount; Instant accrualDate; }
集約が状態を変更すると、ドメインイベントを発行できます。システムの他の部分（同じまたは異なる境界づけられたコンテキスト内）は、これらのイベントを購読し、発行元の集約に直接結合することなく、それに応じて反応できます。例えば、AccountOpenedEventは、「ウェルカムキット」境界づけられたコンテキストや「報告」境界づけられたコンテキストのプロセスをトリガーするかもしれません。
5は、ドメインイベントを「ドメイン内で重要なことが発生したことを示すもの」と定義し、「システム間の疎結合な連携を促進します」と述べています。「注文が完了した」が例として挙げられています。20は、イベントソーシングや統合イベントのハンドラを含むドメインイベントの実装パターンについて議論しています。13は、「ドメインイベントの重要な利点は、副作用を明示的に表現できることです」と述べています。ドメインイベントクラスは、反応的でスケーラブルで保守性の高い金融システムを構築するために不可欠です。
分離という役割を超えて、永続化されたドメインイベントクラスのストリームは、すべての重要なビジネス事象の不変のログとして機能します。この「イベントストリーム」は、監査、複雑な問題のデバッグ、およびビジネスインテリジェンスの導出（例：ローン申請、支払失敗の傾向分析）に非常に価値があります。これはイベントソーシングのような概念と一致します 20。ドメインイベントは発生した重要なビジネスファクトを表します 5。これらのイベントは永続化できます（例：イベントストア内、20でイベントソーシングの文脈で言及）。システム内のすべての重要な状態変化がドメインイベントクラスとしてキャプチャされれば、このイベントシーケンスはシステムのビジネスオペレーションの完全な履歴を形成します。この履歴ログは本質的に不変です（イベントは過去の事実です）。厳格な監査およびコンプライアンス要件を持つ金融システムにとって（金融の性質から暗黙的に要求される）、このような不変のログは非常に価値があります。これにより、履歴の再生、特定の状態に至った経緯の理解、コンプライアンスの証明が可能になります。さらに、このイベントクラスのストリームは、運用データベースに直接負荷をかけることなく、分析システムによって消費され、洞察を導き出し、KPIを追跡し、傾向を特定することができます。例えば、
LoanApplicationSubmittedEventとLoanApprovedEventのデータを時系列で分析することで、承認率やボトルネックを明らかにすることができます。したがって、豊富なドメインイベントクラスの設計は、システム統合のためだけでなく、多くの金融機関における重要な非機能要件である強力な監査およびビジネス分析機能の基盤も築きます。23（Trezyのケーススタディ）は、イベントソーシング（ドメインイベントに依存する）がどのようにしてより良い報告と監査可能な取引分類を可能にしたかを示しています。


6. 戦略的なクラス配置：ドメインレイヤー


レイヤードアーキテクチャ（例：クリーンアーキテクチャ、オニオンアーキテクチャ、ヘキサゴナルアーキテクチャ）において、ドメインレイヤーは中核です 3。エンティティ、値オブジェクト、集約ルート、ドメインサービス、リポジトリインターフェース、ドメインイベントクラスといったすべての主要なドメインクラスは、ドメインレイヤーに配置されます。このレイヤーは、アプリケーション、インフラストラクチャ、UIといった他のレイヤーに依存すべきではありません 3。
3は、「ドメイン層がソフトウェアの核心」であり、「ドメイン層は他のどの層にも依存しない」と明確に述べています。11は、ヘキサゴナルアーキテクチャやオニオンアーキテクチャのようなレイヤードアーキテクチャは、「ドメイン層をどうやって分離するか」に関するものであると述べています。
ドメインレイヤーは他のレイヤーと次のように相互作用します。
         * アプリケーションレイヤー： ドメインレイヤーへの呼び出しを調整するアプリケーションサービス（ユースケース）を含みます。リポジトリから集約を取得し、それら（またはドメインサービス）のメソッドを呼び出し、その後リポジトリを使用して変更を保存します。また、ドメインイベントを発行したり、それらを統合イベントに変換したりすることもあります 18。
         * インフラストラクチャレイヤー： リポジトリインターフェース（データベースアクセス用）、メッセージキュー（イベント発行/処理用）、および外部システム（例：決済ゲートウェイ）へのインターフェースを実装します。
         * プレゼンテーション/UIレイヤー： アプリケーションレイヤーと対話し、ドメインレイヤーとは直接対話しません。
この分離の利点は、テスト容易性（ドメインレイヤーはUIやデータベースの依存関係なしに単独でテスト可能）、保守性（インフラストラクチャの変更がドメインロジックに与える影響が最小限）、および集中（開発者が技術的な懸念に気を取られることなくビジネスロジックに集中できる）です 3。3は、「ドメインの世界ではDBやWEBなどの具体的な手段の話は一切出てこないし、それに依存することもない」と強調しています。適切なレイヤリングにより、クラスにカプセル化された価値あるドメインロジックが純粋に保たれ、外部の懸念から保護されることが保証されます。
ドメインレイヤー内のクラスは、金融機関の運営方法に特有の、成文化されたビジネスルール、プロセス、および知識を表します。これは、その競争優位性と知的財産のかなりの部分を占めます。このレイヤーを技術的な変化や外部依存から保護することは、DDDのアーキテクチャ原則の主要な戦略的利点です。金融機関の競争力は、多くの場合、独自の製品、リスクモデル、顧客サービスプロセス、および運用効率にあります。DDDは、この複雑なビジネス知識をソフトウェア、特にドメインモデル内に直接取り込むことを目指しています 1。ドメインレイヤーのクラス（エンティティ、VO、集約、ドメインサービス）は、このビジネス知識とロジックの明示的な表現です 3。3と11が提唱するように、このドメインレイヤーをインフラストラクチャの懸念（データベース、メッセージングシステム、UIフレームワーク）から分離することにより、中核となるビジネスロジックは技術的変化に対してより回復力のあるものになります。例えば、銀行がオンプレミスのデータベースからクラウドデータベースに移行したり、フロントエンド技術を変更したりすることを決定した場合でも、ドメインレイヤーの中核となる金融ロジッククラスは理想的には影響を受けないはずです。これは、これらの複雑な金融ルールの分析、モデリング、および実装に費やされた多大な投資が長期にわたって維持されることを意味します。したがって、ドメインレイヤーのクラスは単なるコードではなく、機関の運用インテリジェンスを表す価値ある進化する資産です。その慎重な設計と保護が最も重要です。


7. 金融DDDにおけるクラス設計の結論と推奨事項


堅牢な金融システムを構築するためには、エンティティ、値オブジェクト、集約、ドメインサービス、リポジトリ、ファクトリ、そしてドメインイベントといったクラスタイプの重要性を再認識する必要があります。これらの要素は、ドメイン駆動設計（DDD）の原則に基づいて金融システムの複雑な要求に対応するための基盤を提供します。
クラス設計は一度きりの活動ではなく、ドメインエキスパートとの継続的な協調作業を通じて洗練されていく反復的なプロセスです 3。イベントストーミングやユーザーストーリーマッピングのようなテクニックを活用して、クラスとなるドメインの概念を発見することが推奨されます。「ドメインエキスパートと対話しながら知識を深掘りし...モデルに反映する」というループが重要であり 3、「専門家と密なコミュニケーションを取り、しっかり力を借りることが大切です」 21。
初期のモデリング作業は、金融システムのコアとなるドメイン、つまり最もビジネス価値が高いか競争上の差別化をもたらす領域に集中すべきです 3。集約を早期に特定することは、トランザクションの境界と主要なビジネスルールを定義するのに役立ちます。ドメインの「価値のある、複雑な部分」に焦点を当てることが推奨されます 3。コアとなるドメインとサブドメインの区別も重要です 18。
クラスは単なるデータホルダーであってはなりません。ビジネスロジックとルール（不変条件）を、特に集約ルート内にカプセル化すべきです 3。オブジェクトが金融ドメインで何をするのかを考え、単にどのようなデータを持っているかだけを考えるべきではありません。「コードは「処理の手続きを記述する」のではなく、「モデルをそのまま表現する」という感じ」であるべきであり 3、「ユビキタスな表現を行うことでよりビジネスルールを明確にします」 16。
特に金融においては、Money、日付、その他の記述的な値に対して値オブジェクトの不変性を採用することが、予測可能性を保証し、意図しない副作用を防ぐために極めて重要です 2。
クラスは凝集性を保ち、妥当な範囲で小さく保つべきです。単一責任の原則を適用し、多くのことをやろうとするゴッドクラスの作成を避けるべきです。境界づけられたコンテキストはこの点で役立ちます。
最終的に、金融DDDシステムにおけるクラス設計は、発見と洗練の旅です。DDDの原則とパターンに従うことで、チームは技術的に健全であるだけでなく、複雑で絶えず進化する金融の世界と深く整合したシステムを作成できます。この整合性が、持続可能で価値のある金融ソフトウェアを構築するための鍵となります 1。
引用文献
         1. 【初心者がDDDを理解するまでpart1】ドメイン駆動設計とは？ - Qiita, 6月 10, 2025にアクセス、 https://qiita.com/bearl27/items/0563e2a021ccf88ac23e
         2. Mastering Financial Complexity with Money Patterns in Domain-Driven Design, 6月 10, 2025にアクセス、 https://dev.to/sharpassembly/mastering-financial-complexity-with-money-patterns-in-domain-driven-design-13p0
         3. DDDを実践するための手引き（概論・導入編） - Zenn, 6月 10, 2025にアクセス、 https://zenn.dev/kohii/articles/b96634b9a14897
         4. ふわっと理解するDDD ~ドメイン駆動設計~ #初心者 - Qiita, 6月 10, 2025にアクセス、 https://qiita.com/yu-saito-ceres/items/f73262cedcdd6e8e75c8
         5. ドメイン駆動設計（DDD）の基礎と実践｜buffalo - note, 6月 10, 2025にアクセス、 https://note.com/oboe692/n/n4afa88916902
         6. ドメイン駆動設計完全に理解した - Zenn, 6月 10, 2025にアクセス、 https://zenn.dev/m10maeda/articles/i-had-domain-driven-design-down-pat
         7. ドメイン駆動設計（DDD）がソフトウェア開発プロセスに与える ..., 6月 10, 2025にアクセス、 https://www.issoh.co.jp/tech/details/4320/
         8. ドメイン駆動設計にまつわる概念 - Zenn, 6月 10, 2025にアクセス、 https://zenn.dev/imamura_sh/articles/ddd-summary-f85323ffc1b91d82f795
         9. 事業貢献につながるドメイン駆動設計の実践 - ころがるおもち, 6月 10, 2025にアクセス、 https://korogaruomochi.com/practical-domain-driven-design-for-business-success/
         10. 戦術的 DDD を使用したマイクロサービスの設計 - Azure Architecture ..., 6月 10, 2025にアクセス、 https://learn.microsoft.com/ja-jp/azure/architecture/microservices/model/tactical-ddd
         11. 「ドメイン駆動設計 (DDD) とは？」を戦略的設計・戦術的設計に分けて理解する, 6月 10, 2025にアクセス、 https://www.kanzennirikaisita.com/posts/domain-driven-design-concepts/
         12. 【サブドメインにSEO効果は引き継げる？】サブディレクトリとの違いを解説 | WEB(SEO)集客に強い編集プロダクション｜株式会社シンプリック, 6月 10, 2025にアクセス、 https://simplique.jp/subdomain-subdirectory/
         13. younos1986/DDDBanking - GitHub, 6月 10, 2025にアクセス、 https://github.com/younos1986/DDDBanking
         14. README.md - j5ik2o/java-ddd-example - GitHub, 6月 10, 2025にアクセス、 https://github.com/j5ik2o/java-ddd-example/blob/master/README.md
         15. 8 Key Concepts in Domain-Driven Design - ByteByteGo, 6月 10, 2025にアクセス、 https://bytebytego.com/guides/8-key-concepts-in-ddd/
         16. 集約で境界を正しく表現する意味 #DDD - Qiita, 6月 10, 2025にアクセス、 https://qiita.com/kichion/items/3826277eb372826a313e
         17. レガシーシステムからの脱却を加速する！グラフ理論に基づくアプリケーション分割 - NTT Data, 6月 10, 2025にアクセス、 https://www.nttdata.com/jp/ja/trends/data-insight/2022/0203/
         18. DDD(ドメイン駆動設計)の魅力と実践：AIエージェント・戦略的設計から戦術的設計まで - note, 6月 10, 2025にアクセス、 https://note.com/tatsuyamatsuda/n/n671ce4e03d48
         19. ドメイン駆動設計を用いてマイクロサービスに分割することを考える #DDD - Qiita, 6月 10, 2025にアクセス、 https://qiita.com/tsukmr/items/1f8f68f7d9f28cd20380
         20. DDDを実践するための手引き（ドメインイベント編） - Zenn, 6月 10, 2025にアクセス、 https://zenn.dev/kohii/articles/4a68e768c93573
         21. ドメイン駆動設計（DDD）とは？基礎知識や進め方、成功させるためのポイント - Qbook, 6月 10, 2025にアクセス、 https://www.qbook.jp/column/1849.html
         22. ドメイン駆動設計入門（DDD）を読んでみて - Zenn, 6月 10, 2025にアクセス、 https://zenn.dev/spacemarket/articles/6a4fb0969dce36
         23. Case Study: How Trezy Transformed Financial Data ... - Arkency, 6月 10, 2025にアクセス、 https://arkency.com/case-study/trezy/
         24. Domain-driven-design--code-sample/ddd-to-the-code ... - GitHub, 6月 10, 2025にアクセス、 https://github.com/vaquarkhan/Domain-driven-design--code-sample/blob/master/ddd-to-the-code-workshop-accounting/src/main/java/com/github/cstettler/dddttc/accounting/domain/Wallet.java
         25. 【2023年最新版！】金融業界のDX事例10選！ DXのメリットについてもまとめて紹介！！, 6月 10, 2025にアクセス、 https://www.primagest.co.jp/column/1519/
         26. グローバル展開も視野に入れた決済プラットフォームにドメイン駆動設計(DDD)を取り入れた, 6月 10, 2025にアクセス、 https://blog.kinto-technologies.com/posts/2022_08_30_start_ddd/