# 第1章: はじめに - DDDアンチパターンを理解する

ドメイン駆動設計（DDD）は複雑なドメインのソフトウェア開発において強力なアプローチですが、その原則の誤解や不適切な適用は、意図しない有害な結果、すなわち**アンチパターン**を生み出す可能性があります。

アンチパターンとは、頻繁に用いられるものの、非効率的であったり、有害でさえある解決策を指します。DDDの文脈におけるアンチパターンは、保守性やビジネスニーズとの整合性が困難なシステムをもたらす、DDD原則の一般的な誤解や誤適用を表します。

これらのアンチパターンを認識し、早期に対処することは、ソフトウェアの品質、開発効率、そしてビジネスとの整合性にとって極めて重要です。

---

# 第2章: 戦術的設計のアンチパターン

戦術的設計は、モデルを構成する具体的な要素（エンティティ、値オブジェクト、集約など）の実装に関わります。これらの構成要素の誤用や誤解は、多くのアンチパターンを引き起こします。

## 2.1. 貧血ドメインモデル (Anemic Domain Model)

-   **定義**: ドメインオブジェクトがビジネスロジックをほとんど、あるいは全く含まず、単なるデータの入れ物（プロパティとゲッター/セッターのみ）となっている状態。ロジックは別のサービスクラスに実装されます。
-   **影響**:
    -   カプセル化の原則に違反し、データと振る舞いが分離される。
    -   検証ロジックが分散し、オブジェクトの一貫性を保証しにくくなる。
    -   コードの重複リスクが増加し、保守性が低下する。
-   **解決策**:
    -   **豊かなドメインモデル**を目指し、データとそれを操作するロジックを同じオブジェクト内にカプセル化する。
    -   公開セッターを避け、状態を変更する操作はビジネスの振る舞いを表すメソッドを通じて行う。
    -   エンティティが自身の不変条件（ビジネスルール）を強制するように設計する。

## 2.2. スマートUI (Smart UI)

-   **定義**: ビジネスロジック、データアクセス、ドメインルールなどがユーザーインターフェース（UI）層に混在している状態。
-   **影響**:
    -   関心の分離が破壊され、「スパゲッティコード」化する。
    -   ビジネスロジックの再利用が困難になる。
    -   UIの変更が意図せずビジネスロジックに影響を与えるリスクが高まる。
-   **解決策**:
    -   レイヤードアーキテクチャを徹底し、UI、アプリケーション、ドメイン、インフラストラクチャの各層を明確に分離する。
    -   ビジネスロジックはドメイン層に配置し、UIはドメインの状態を表示し、ユーザー入力をアプリケーション層に渡す役割に徹する。

## 2.3. トランザクションスクリプト (Transaction Script)

-   **定義**: ユーザーのアクションごとに、ビジネスロジックを単一の手続きとして実装するスタイル。リッチなドメインオブジェクトとの相互作用はほとんどありません。
-   **影響**:
    -   複雑なトランザクションにおいてコードの重複が発生しやすい。
    -   ビジネスロジックとデータアクセスが密結合する。
    -   オブジェクト指向の利点を活かせず、手続き的な設計に陥る。
-   **解決策**:
    -   ドメインモデルを採用し、ビジネスロジックをエンティティや値オブジェクトにカプセル化する。
    -   アプリケーションサービスは、ドメインオブジェクトへの操作を調整する薄い層として機能させる。

## 2.4. アグリゲートのアンチパターン

### A. 巨大なアグリゲート
-   **問題点**: 一つのアグリゲートが過度に多くのオブジェクトを内包し、大きすぎること。
-   **影響**: パフォーマンスの低下、高い並行処理競合、低い凝集度。
-   **解決策**:
    -   **小さなアグリゲート**を設計する。真の不変条件（常に一貫性を保つべきルール）のみをアグリゲートの境界内に含める。
    -   アグリゲート間の整合性は、**ドメインイベント**と**結果整合性**を利用して実現する。

### B. IDではなくオブジェクトで他のアグリゲートを参照する
-   **問題点**: アグリゲート内に、他のアグリゲートルートへの直接的なオブジェクト参照を保持すること。
-   **影響**: アグリゲートの独立した境界が曖昧になり、意図せず他のアグリゲートを変更してしまうリスクがある。大規模なオブジェクトグラフがロードされ、パフォーマンスが悪化する。
-   **解決策**: 他のアグリゲートは、その**ID（識別子）**のみで参照する。他のアグリゲートの情報が必要な場合は、リポジトリを使ってIDで明示的に取得する。

## 2.5. 値オブジェクトの誤解

### A. プリミティブへの執着 (Primitive Obsession)
-   **問題点**: メールアドレス、金額、郵便番号といったドメインの概念を、単なる文字列や整数などのプリミティブ型で表現すること。
-   **影響**: ドメインの知識（検証ルールなど）がコードの至る所に散在し、表現力が低下する。
-   **解決策**: 独自の意味を持つ概念は、プリミティブではなく**値オブジェクト**としてカプセル化する。

```java
// --- アンチパターン：プリミティブへの執着 ---
public class Customer {
    private String email; // 単なるString

    public void changeEmail(String newEmail) {
        // 検証ロジックが利用する側に散在する
        if (newEmail == null || !newEmail.contains("@")) {
            throw new IllegalArgumentException("不正なメールアドレスです。");
        }
        this.email = newEmail;
    }
}


// --- 解決策：値オブジェクトとしてカプセル化 ---
public final class EmailAddress {
    private final String value;

    public EmailAddress(String value) {
        // 検証ロジックをコンストラクタに集約
        if (value == null || !value.contains("@")) {
            throw new IllegalArgumentException("不正なメールアドレスです。");
        }
        this.value = value;
    }
    // equals, hashCode, toString...
}

public class Customer {
    private EmailAddress email;

    public void changeEmail(EmailAddress newEmail) {
        // ドメインの概念でやり取りできる
        this.email = Objects.requireNonNull(newEmail);
    }
}
```

### B. 変更可能な値オブジェクト
-   **問題点**: 値オブジェクトを変更可能（ミュータブル）に設計すること。
-   **影響**: 予期せぬ副作用（エイリアシングバグ）を引き起こす可能性がある。
-   **解決策**: 値オブジェクトは常に**不変（イミュータブル）**に設計する。値の変更が必要な場合は、新しいインスタンスを作成して返す。

## 2.6. リポジトリのアンチパターン

-   **問題点**:
    -   リポジトリがアグリゲートルート以外のエンティティを返す。
    -   リポジトリがORM固有のクエリ（`IQueryable`など）を広範囲に公開し、永続化の懸念が上位層に漏洩する。
    -   リポジトリ内にビジネスロジックが含まれる。
-   **解決策**:
    -   リポジトリは**アグリゲートルート**の取得と保存のみに責任を持つ。
    -   リポジトリは、ドメインの要求に基づいた意図の明確なメソッド（例: `findApprovedOrders()`）を公開する。
    -   リポジトリはデータ永続化に専念し、ビジネスロジックはドメインオブジェクトやドメインサービスに配置する。

---

# 第3章: 戦略的設計のアンチパターン

戦略的設計は、システム全体の構造や、ビジネスドメインの各部分がどう関連し合うかに焦点を当てます。このレベルでのアンチパターンは、プロジェクト全体を誤った方向に導く可能性があります。

## 3.1. 軽視されたユビキタス言語

-   **問題点**: 開発者とドメインエキスパートが共通の厳密な言語（ユビキタス言語）を育成し、使用することを怠ること。
-   **影響**: 誤解、バグ、要求仕様の曖昧さが生じ、ソフトウェアがビジネスの現実から乖離する。
-   **解決策**: ドメインエキスパートと密接に協力し、会話、ドキュメント、コードのすべてで一貫したユビキタス言語を積極的に使用し、維持する。

## 3.2. 境界づけられたコンテキストのアンチパターン

### A. 曖昧な境界
-   **問題点**: 境界づけられたコンテキスト（BC）の境界が明確に定義されていない。
-   **影響**: 異なるコンテキストのモデルが混在し、意図しない結合や混乱を生む。
-   **解決策**: BCの境界を明示的に定義・文書化する。**コンテキストマップ**を使い、BC間の関係性を視覚化する。

### B. 神コンテキスト (God Context)
-   **問題点**: 一つのBCが過度に多くのサブドメインを包含し、巨大化してしまうこと。
-   **影響**: 「巨大な泥だんご」アーキテクチャにつながり、保守性やスケーラビリティが著しく低下する。
-   **解決策**: ドメインを論理的なサブドメインに適切に分割し、それぞれを独立したBCとして扱う。

## 3.3. コンテキストマップの欠如

-   **問題点**: 境界づけられたコンテキスト間の関係性を視覚的に示すコンテキストマップを作成しないこと。
-   **影響**: チーム間の連携が困難になり、システム全体の構造が不明確になる。統合に関する問題が発生しやすくなる。
-   **解決策**: 定期的にコンテキストマップを更新し、チーム間の関係性（共有カーネル、顧客/供給者、防護層など）を明確に定義し、共有する。

</rewritten_file>