# ドメイン駆動設計（DDD）におけるモダンなテスト戦略ガイド

## 1. はじめに

### 1.1. 本ガイドの目的

このガイドは、ドメイン駆動設計（DDD）を採用したプロジェクトにおいて、効果的かつ持続可能なテスト戦略を構築するための指針を提供します。DDDの各要素（エンティティ、値オブジェクト、集約、ドメインサービス、リポジトリ、アプリケーションサービスなど）に対応した、具体的で実践的なテスト手法を解説します。

### 1.2. DDDにおけるテストの重要性

DDDプロジェクトの成功は、ドメインモデルの正確性と堅牢性に大きく依存します。テストは、以下の目的を達成するための不可欠な活動です。

-   **ドメインロジックの正確性の保証**: ビジネスルールが正しく実装されていることを確認します。
-   **リファクタリングの安全性確保**: 複雑なドメインモデルを安心して改善するためのセーフティネットを提供します。
-   **コミュニケーションの促進**: テストコードは、ドメインエキスパートと開発者の共通理解を深めるための「生きたドキュメント」として機能します。
-   **設計へのフィードバック**: 書きにくいテストは、設計の問題点（例：関心の分離が不十分、凝集度が低い）を早期に発見するシグナルとなります。

### 1.3. テスト戦略の基本方針

本ガイドで提唱するテスト戦略は、以下の原則に基づいています。

-   **テストピラミッド/テストダイヤモンドの遵守**: 単体テストを土台としつつ、ドメインの振る舞いを検証する統合テストに重点を置きます。
-   **関心の分離**: テスト対象に応じて、テストの目的と範囲を明確に分離します（例：ドメインロジックのテスト vs インフラストラクチャのテスト）。
-   **振る舞い駆動開発（BDD）の思想の活用**: テストを「仕様」として捉え、ビジネス要件とコードの連携を強化します。
-   **実装の詳細からの独立**: テストは「何を」達成するべきかを検証し、「どのように」実装されているかという詳細に依存しないようにします。

---

## 2. アーキテクチャとテスト容易性

テスト容易性の高いシステムを構築するには、アーキテクチャレベルでの設計が不可欠です。

### 2.1. ヘキサゴナルアーキテクチャ（ポート＆アダプター）

このアーキテクチャは、関心の分離を徹底し、テスト容易性を最大化するための強力な基盤を提供します。

-   **ドメイン層（中心）**: ビジネスロジックの核心。いかなる外部層にも依存せず、純粋なドメイン知識をカプセル化します。
-   **アプリケーション層**: ユースケースを実装。ドメイン層のオブジェクトを調整し、インフラ層のインターフェース（ポート）を呼び出します。
-   **インフラストラクチャ層（外側）**: データベース、外部API、UIなど、外部技術との連携を担当。ドメイン層やアプリケーション層で定義されたポート（インターフェース）を実装（アダプター）します。

この構造により、ドメイン層は外部の技術的詳細から完全に隔離され、高速で安定した単体テストが可能になります。

### 2.2. 依存関係逆転の原則

-   **原則**: 上位のレイヤーは下位のレイヤーに依存してはなりません。両方とも抽象に依存すべきです。
-   **実践**: ドメイン層がインフラ層の具象クラスに依存するのではなく、ドメイン層が定義したインターフェース（ポート）をインフラ層が実装します。これにより、ドメインモデルの純粋性が保たれます。

---

## 3. テストピラミッド戦略

DDDプロジェクトにおけるテスト戦略は、伝統的なテストピラミッドに従います。

-   **レベル1: 単体テスト (Unit Tests) - 70%**
    -   **対象**: ドメイン層（エンティティ、値オブジェクト、集約、ドメインサービス）。
    -   **特徴**: 最も数が多く、高速で安定。外部依存なしでメモリ上で完結。ビジネスロジックの正確性を保証する上で最も重要。
-   **レベル2: 統合テスト (Integration Tests) - 20%**
    -   **対象**: アプリケーションサービス、リポジトリ、外部API連携。
    -   **特徴**: 複数のコンポーネント間の連携を検証。データベースやファイルシステムなど、外部インフラとの接続を含む。単体テストより遅く、数は少なくなる。
-   **レベル3: E2E（エンドツーエンド）テスト - 10%**
    -   **対象**: UIからデータベースまでの完全なユーザーストーリー。
    -   **特徴**: システム全体が正しく機能することを保証。実行コストが最も高く、不安定になりやすいため、主要な「ハッピーパス」シナリオに限定する。

---

## 4. 各DDDコンポーネントのテスト戦略

### 4.1. 値オブジェクト (Value Object) のテスト

-   **焦点**: 不変性、等価性、検証ロジック。
-   **戦略**:
    -   **生成時**: 有効な値で正しく生成されること、無効な値では例外がスローされることをテストします。
    -   **等価性**: 同じ属性を持つ2つのインスタンスが `equals()` で `true` を返すこと、およびハッシュコードが一致することを確認します。
    -   **不変性**: オブジェクトの状態を変更しようとする操作が、新しいインスタンスを返す（元のインスタンスは不変のまま）ことを確認します。

### 4.2. エンティティと集約 (Entity & Aggregate) のテスト

-   **焦点**: ビジネスルール、状態遷移、ドメインイベントの発行。
-   **戦略**:
    -   **テスト単位は集約全体**: 集約ルートを介してのみ操作を行います。内部のエンティティを直接テストしません。
    -   **状態の検証**: ある操作（メソッド呼び出し）の後、集約の状態（プロパティ）が期待通りに変化したことをアサートします。
    -   **振る舞いの検証**: 操作の結果として、期待されるドメインイベントが発行されたことを確認します。
    -   **境界条件**: 不変条件（ビジネスルール）に違反する操作が、適切に例外をスローすることをテストします。

### 4.3. ドメインサービス (Domain Service) のテスト

-   **焦点**: 複数の集約をまたぐロジックや、特定の集約に属さないドメインロジック。
-   **戦略**:
    -   ドメインサービスはステートレスであるべきです。
    -   必要な集約や値オブジェクトを引数として渡し、その戻り値や、引数として渡したオブジェクトの状態変化を検証します。
    -   依存する集約は、実インスタンスまたはテストダブル（スタブ、フェイク）を使用します。

### 4.4. リポジトリ (Repository) のテスト

-   **焦点**: 永続化と取得ロジックの正しさ。
-   **種類**: 統合テスト。
-   **戦略**:
    -   ORMやDBドライバはモック化しません。
    -   Testcontainersやインメモリデータベース（H2など）を使用して、実際のDBに近い環境でテストします。
    -   **基本サイクル**:
        1.  集約をリポジトリに保存 (`save`)。
        2.  IDで集約を再取得 (`findById`)。
        3.  保存前のオブジェクトと再取得したオブジェクトが等価であることをアサートします。
    -   **クエリメソッド**: 特定の条件で検索し、期待される集約（またはそのリスト）が返されることを検証します。

### 4.5. アプリケーションサービス (Application Service) のテスト

-   **焦点**: ユースケースのオーケストレーション（処理の調整役）。
-   **種類**: 統合テスト。
-   **戦略**:
    -   リポジトリや外部APIクライアントなどのインフラ層の依存は、テストダブル（特にインメモリの**フェイク**実装）に置き換えます。
    -   **テストフロー**:
        1.  コマンドオブジェクトを作成し、アプリケーションサービスのメソッドを呼び出します。
        2.  戻り値が期待通りであることを検証します。
        3.  依存するリポジトリの `save` メソッドが呼び出されたことや、イベント発行が指示されたことなど、副作用（Side Effect）を検証します。

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.*;

// インメモリのフェイクリポジトリ
class InMemoryOrderRepository implements OrderRepository {
    private final Map<OrderId, Order> map = new HashMap<>();
    
    @Override
    public Optional<Order> findById(OrderId id) {
        return Optional.ofNullable(map.get(id));
    }
    
    @Override
    public void save(Order order) {
        map.put(order.getId(), order);
    }
    // ...
}

// インメモリのフェイクイベント発行者
class SpyEventPublisher implements DomainEventPublisher {
    public final List<Object> publishedEvents = new ArrayList<>();
    
    @Override
    public void publish(List<Object> events) {
        publishedEvents.addAll(events);
    }
}

class OrderApplicationServiceTest {

    private OrderApplicationService sut; // System Under Test
    private OrderRepository fakeOrderRepository;
    private SpyEventPublisher spyEventPublisher;

    @BeforeEach
    void setUp() {
        fakeOrderRepository = new InMemoryOrderRepository();
        spyEventPublisher = new SpyEventPublisher();
        sut = new OrderApplicationService(fakeOrderRepository, spyEventPublisher);
    }

    @Test
    void 注文を確定するとリポジトリに保存されイベントが発行される() {
        // Given
        Order order = new Order(new OrderId("ORDER-001"), new CustomerId("CUST-123"));
        order.addOrderLine(new Product(/* ... */), 1);
        fakeOrderRepository.save(order);

        // When
        sut.confirmOrder(order.getId());
        
        // Then: 副作用を検証する
        Order savedOrder = fakeOrderRepository.findById(order.getId()).get();
        assertThat(savedOrder.getStatus()).isEqualTo(OrderStatus.CONFIRMED);
        
        assertThat(spyEventPublisher.publishedEvents).hasSize(1);
        assertThat(spyEventPublisher.publishedEvents.get(0)).isInstanceOf(OrderConfirmed.class);
    }
}
```

---

## 5. テストダブルの効果的な使い方

テストダブル（モック、スタブ、フェイクなど）は、テストの分離性を高めるために不可欠ですが、使い方を誤るとテストが脆くなります。

-   **スタブ (Stub)**: テスト対象に「入力」を提供します。リポジトリの `findById` のように、データを返すメソッドの模倣に使います。テストの**状態検証**で使用します。
-   **モック (Mock)**: テスト対象からの「出力」を検証します。メール送信サービスのように、戻り値がなく副作用を持つメソッドが呼び出されたかを確認するために使います。テストの**振る舞い検証**で使用します。
-   **フェイク (Fake)**: 実際に動作する軽量な実装です。インメモリデータベースや、コレクションで代用したインメモリリポジトリが典型例です。モックよりも堅牢なテストを可能にします。

### 指針

-   **原則として、自分が所有していない「管理外の依存関係」のみをモックする。**
    -   **OK**: 外部の決済ゲートウェイAPI、メール送信サービスなど。これらはシステムの境界であり、契約です。
    -   **NG**: 自身のデータベース（リポジトリ）。これは実装の詳細です。リポジトリはフェイク実装でテストするか、DB統合テストで検証すべきです。
-   安易なモックは、テストを実装の詳細に密結合させ、リファクタリングを困難にします。モックへの強い依存は、設計上の問題を示唆するサインかもしれません。

---

## 6. まとめ

効果的なDDDのテスト戦略は、以下の要素に基づいています。

1.  **テスト容易なアーキテクチャ**: ヘキサゴナルアーキテクチャで関心事を分離し、ドメインモデルを純粋に保つ。
2.  **健全なテストピラミッド**: 高速な単体テストを土台とし、システムの核心であるドメインロジックを網羅的に検証する。
3.  **コンポーネントごとの戦略**: DDDの各ビルディングブロックの役割に応じて、適切なテスト手法を適用する。
4.  **賢明なテストダブルの使用**: 実装の詳細ではなく、システムの振る舞いや状態を検証するために、モックやフェイクを適切に使い分ける。

このガイドが、あなたのDDDプロジェクトにおける堅牢で保守性の高いテスト文化の構築に役立つことを願っています。 