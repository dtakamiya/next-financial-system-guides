# 第1章: アグリゲートの基礎

## 1.1. アグリゲートとは？

ドメイン駆動設計（DDD）において、**アグリゲート（Aggregate）**は、関連する複数のオブジェクト（エンティティと値オブジェクト）を一つの単位としてまとめたクラスター（集合体）です。アグリゲートは単なるデータの集まりではなく、ドメインにおける**「一貫性の境界（Consistency Boundary）」**として機能します。

主な目的は以下の通りです。

-   **ドメインの複雑性の管理**: 関連性の高いオブジェクト群をカプセル化し、モデルの関心事を分離します。
-   **データ整合性の維持**: アグリゲート内のオブジェクト群は、常にビジネスルールに準拠した一貫した状態を保つ必要があります。
-   **トランザクション境界の定義**: アグリゲートに対する変更は、通常、アトミックな操作（一つのトランザクション）として扱われます。

## 1.2. アグリゲートの構成要素

アグリゲートは、主に以下の要素で構成されます。

-   **アグリゲートルート (Aggregate Root - AR)**
    -   アグリゲートの「守護者」であり、外部からの唯一のアクセスポイントとなる特定のエンティティです。
    -   アグリゲート全体の整合性を維持し、ビジネスルール（不変条件）を強制する責任を持ちます。
    -   外部のオブジェクトは、AR以外の内部オブジェクトに直接アクセスすることはできません。

-   **エンティティ (Entity)**
    -   アグリゲート内に含まれる、一意の識別子を持つオブジェクトです。
    -   AR自身もエンティティですが、それ以外のエンティティは通常、アグリゲート内でのみ意味を持つローカルな識別子を持ちます。

-   **値オブジェクト (Value Object - VO)**
    -   識別子を持たず、その属性の値によって定義される**不変の**オブジェクトです。
    -   エンティティの属性を記述するために使用され、アグリゲートの状態の安定性に寄与します。

---

# 第2章: アグリゲート設計の4大原則

効果的なアグリゲートを設計するためには、Vaughn Vernon氏らが提唱する以下の4つの基本原則に従うことが重要です。

## 2.1. 原則1: 真の不変条件を整合性の境界内でモデル化する

**不変条件（Invariant）**とは、どのような操作が行われようとも、常に真でなければならないビジネスルールのことです。アグリゲートは、この不変条件をその境界内で保護する責任を持ちます。

-   **例**: 「注文の合計金額は、各注文明細の金額の合計と常に一致する」「在庫数は決して負の値にならない」
-   アグリゲートルートは、全ての操作が不変条件を侵害しないかを検証し、一つのトランザクションが完了する時点では、必ず不変条件が満たされている状態を保証します。

## 2.2. 原則2: 小さなアグリゲートを設計する

大きなアグリゲートはパフォーマンスの低下やロック競合を引き起こすため、**アグリゲートは可能な限り小さく設計する**ことが強く推奨されます。

-   **メリット**:
    -   **パフォーマンス向上**: ロード・保存するデータ量が減り、メモリ消費も削減されます。
    -   **スケーラビリティ向上**: トランザクション範囲が狭まることで、ロック競合が減り、システムの並行処理能力が向上します。
    -   **複雑性の低減**: 関心事が限定され、モデルの理解が容易になります。

## 2.3. 原則3: 他のアグリゲートはIDで参照する

アグリゲートが他のアグリゲートを参照する場合、直接的なオブジェクト参照を持つのではなく、**相手のアグリゲートルートのIDのみで参照**します。

-   **メリット**:
    -   **疎結合の促進**: アグリゲート間の結合度が下がり、独立性が保たれます。
    -   **パフォーマンス向上**: 不必要な関連アグリゲートの連鎖的なロードを防ぎます。
    -   **分散システムへの対応**: 各アグリゲートを異なるサービスやデータベースに配置することが容易になります。

```java
// 良くない例：Productオブジェクトを直接参照している
public class Review { // Reviewアグリゲートルート
    private ReviewId id;
    private Product product; // 他のアグリゲートへの直接参照
    private String reviewText;
    // ...
}

// 推奨される例：ProductIdという値オブジェクトで参照する
public class Review { // Reviewアグリゲートルート
    private ReviewId id;
    private ProductId productId; // IDによる参照
    private String reviewText;
    // ...
    
    public Review(ReviewId id, ProductId productId, String text) {
        this.id = id;
        this.productId = productId;
        this.reviewText = text;
    }
}
```

## 2.4. 原則4: アグリゲートの境界外では結果整合性を利用する

複数のアグリゲートにまたがるビジネスプロセスでは、常に即時的な強い整合性を求めるのではなく、**結果整合性（Eventual Consistency）**を利用します。

-   **結果整合性とは**: ある操作の後、システム全体が即座に一貫した状態になるわけではないが、時間が経過すれば最終的には一貫した状態に収束するという性質です。
-   **実現方法**: **ドメインイベント**の発行と、それを購読する非同期なイベントハンドラを通じて実現されるのが一般的です。これにより、システムのパフォーマンスとスケーラビリティが維持されます。

```java
// アプリケーションサービスの例
public class OrderApplicationService {

    private final OrderRepository orderRepository;
    private final DomainEventPublisher eventPublisher;

    // ... コンストラクタ ...

    public void confirmOrder(OrderId orderId) {
        // 1. １つのトランザクションで１つのアグリゲートを変更する
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException());
        
        order.confirm(); // 注文を確定状態にする
        
        orderRepository.save(order);

        // 2. ドメインイベントを発行して、他のアグリゲートへの影響を通知する
        // このイベント発行自体は同じトランザクション内で行われることが多い
        eventPublisher.publish(new OrderConfirmed(order.getId(), order.getCustomerId()));
    }
}

// ドメインイベントを購読するハンドラの例（非同期で実行される）
public class CustomerNotificationHandler {

    private final CustomerRepository customerRepository;

    // ... コンストラクタ ...

    @EventListener // (例: Springの非同期イベントリスナー)
    @Async
    public void handleOrderConfirmed(OrderConfirmed event) {
        // 別のトランザクションで、Customerアグリゲートを更新する
        Customer customer = customerRepository.findById(event.getCustomerId())
            .orElseThrow(() -> new CustomerNotFoundException());
            
        customer.addPurchaseHistory(event.getOrderId()); // 顧客の購入履歴を追加
        
        customerRepository.save(customer);
    }
}
```

---

# 第3章: アグリゲートの一般的なアンチパターンとその克服

アグリゲート設計で陥りがちなアンチパターンを理解し、それを避けることは非常に重要です。

## 3.1. アンチパターン1: 「神」アグリゲート（過度に大きなアグリゲート）

-   **問題**: 一つのアグリゲートが多くの責務を抱え込みすぎ、パフォーマンス低下、ロック競合、保守性の悪化を招きます。
-   **原因**: トランザクション境界の誤解、結果整合性への恐れ。
-   **克服法**:
    -   **境界の見直し**: 真の不変条件に基づいてアグリゲートの境界を再定義し、より小さなアグリゲートに分割します。
    -   **結果整合性の採用**: アグリゲート間の連携にはドメインイベントと結果整合性を積極的に活用します。

## 3.2. アンチパターン2: 貧血のアグリゲート（振る舞いの欠如）

-   **問題**: アグリゲートがビジネスロジックを持たず、単なるデータの入れ物になってしまう状態。ロジックはサービス層などに分散し、カプセル化が崩壊します。
-   **原因**: 伝統的な階層型アーキテクチャの影響、DDD原則の誤解。
-   **克服法**:
    -   **振る舞いの注入**: サービス層にあるビジネスロジックを、関連するアグリゲートルートのメソッドとして移動させます。
    -   **状態の保護**: プロパティへの直接的な変更を防ぐため、公開セッターをなくし、状態変更は必ずビジネスの意味を持つメソッドを通じて行います。

## 3.3. アンチパターン3: 内部状態の漏洩

-   **問題**: アグリゲートの外部から、アグリゲートルートを介さずに内部のオブジェクトを直接変更できてしまう状態。不変条件が容易に破壊されます。
-   **原因**: 安易なgetterの公開（特にコレクション）、カプセル化の軽視。
-   **克服法**:
    -   **不変なビューを返す**: 内部のコレクションを返す際は、変更不可能なビュー（読み取り専用のコピーやラッパー）を返します。
    -   **コマンドメソッドの提供**: 内部状態を変更するための専用のコマンドメソッド（例: `addItem()`）をアグリゲートルートに用意し、外部からはそれを呼び出すようにします。

```java
public class Order { // 集約ルート

    private final List<OrderLine> orderLines;

    // ...

    // 良くない例：内部のリストを直接返してしまう
    public List<OrderLine> getOrderLines_Bad() {
        return this.orderLines; // 外部からリストが変更されてしまう！
    }

    // 良い例：変更不可能なビューを返す
    public List<OrderLine> getOrderLines_Good() {
        return Collections.unmodifiableList(this.orderLines);
    }
    
    // 良い例：または、DTOのリストに変換して返す
    public List<OrderLineDTO> getOrderLinesAsDTO() {
        return this.orderLines.stream()
                              .map(line -> new OrderLineDTO(line))
                              .collect(Collectors.toList());
    }

    // 内部状態を変更するためのコマンドメソッド
    public void addOrderLine(Product product, int quantity) {
        // ... 不変条件をチェックするロジック ...
        OrderLine line = new OrderLine(product.getId(), product.getPrice(), quantity);
        this.orderLines.add(line);
        // ...
    }
}
```

## 3.4. アンチパターン4: 不適切なトランザクション境界

-   **問題**: 一つのトランザクションで複数のアグリゲートを変更しようとすること。ロック競合やデッドロックのリスクを高め、スケーラビリティを著しく低下させます。
-   **原因**: 全ての操作に対する強整合性の要求、ドメインイベントの知識不足。
-   **克服法**:
    -   **「1トランザクション1アグリゲート」の原則遵守**: 一つのユースケース（アプリケーションサービスメソッド）は、原則として一つのアグリゲートの変更に限定します。
    -   **ドメインイベントの活用**: 複数のアグリゲートにまたがるプロセスは、ドメインイベントを介した結果整合性で実現します。

## 3.5. アンチパターン5: UI駆動のアグリゲート設計

-   **問題**: アグリゲートの設計が、ドメインの本質的な概念ではなく、特定のUI画面の要件に引きずられてしまうこと。モデルが不安定になり、再利用性が低下します。
-   **原因**: ドメイン理解の不足、短期的な視点での実装。
-   **克服法**:
    -   **ドメインの本質に集中**: アグリゲートの境界は、UIではなく、ドメイン内の不変条件やビジネスルールに基づいて決定します。
    -   **CQRSの検討**: 複雑な画面表示要件がある場合は、コマンド（更新系）とクエリ（参照系）のモデルを分離するCQRSパターンの導入を検討することも有効です。 